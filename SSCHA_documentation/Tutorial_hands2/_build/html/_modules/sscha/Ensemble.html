
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sscha.Ensemble &#8212; python-sscha 1.2 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sscha.Ensemble</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span>



<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This is part of the program python-sscha</span>
<span class="sd">Copyright (C) 2018  Lorenzo Monacelli</span>

<span class="sd">This program is free software: you can redistribute it and/or modify</span>
<span class="sd">it under the terms of the GNU General Public License as published by</span>
<span class="sd">the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">(at your option) any later version.</span>

<span class="sd">This program is distributed in the hope that it will be useful,</span>
<span class="sd">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">GNU General Public License for more details.</span>

<span class="sd">You should have received a copy of the GNU General Public License</span>
<span class="sd">along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;. </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">cellconstructor</span> <span class="k">as</span> <span class="nn">CC</span>
<span class="kn">import</span> <span class="nn">cellconstructor.Structure</span>
<span class="kn">import</span> <span class="nn">cellconstructor.Phonons</span>
<span class="kn">import</span> <span class="nn">cellconstructor.Methods</span>
<span class="kn">import</span> <span class="nn">cellconstructor.Manipulate</span>
<span class="kn">import</span> <span class="nn">cellconstructor.Settings</span>

<span class="kn">import</span> <span class="nn">sscha.Parallel</span> <span class="k">as</span> <span class="nn">Parallel</span>
<span class="kn">from</span> <span class="nn">sscha.Parallel</span> <span class="kn">import</span> <span class="n">pprint</span> <span class="k">as</span> <span class="nb">print</span>

<span class="kn">import</span> <span class="nn">difflib</span>

<span class="kn">import</span> <span class="nn">SCHAModules</span>
<span class="c1">#import sscha_HP_odd</span>

<span class="n">_SSCHA_ODD_</span> <span class="o">=</span> <span class="kc">False</span> 
<span class="c1">#try:</span>
<span class="c1">#    import sscha_HP_odd</span>
<span class="c1">#    _SSCHA_ODD_ = True</span>
<span class="c1">#except:</span>
<span class="c1">#    _SSCHA_ODD_ = False </span>


<span class="c1"># Try to load the parallel library if any</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
    <span class="n">__MPI__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">__MPI__</span> <span class="o">=</span> <span class="kc">False</span>
    
<span class="c1"># Check if you can load spglib</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">spglib</span>
    <span class="n">__SPGLIB__</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span><span class="p">:</span> 
    <span class="n">__SPGLIB__</span> <span class="o">=</span> <span class="kc">False</span>
    
<span class="n">__ASE__</span> <span class="o">=</span> <span class="kc">True</span> 
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">ase</span><span class="o">,</span> <span class="nn">ase.io</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">__ASE__</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># The small value considered zero</span>
<span class="n">__EPSILON__</span> <span class="o">=</span>  <span class="mf">1e-6</span>
<span class="n">__A_TO_BOHR__</span> <span class="o">=</span> <span class="mf">1.889725989</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">ase.units</span> <span class="kn">import</span> <span class="n">create_units</span>
    <span class="n">units</span> <span class="o">=</span> <span class="n">create_units</span><span class="p">(</span><span class="s2">&quot;2006&quot;</span><span class="p">)</span><span class="c1">#Rydberg, Bohr</span>
    <span class="n">Rydberg</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="s2">&quot;Ry&quot;</span><span class="p">]</span>
    <span class="n">Bohr</span> <span class="o">=</span> <span class="n">units</span><span class="p">[</span><span class="s2">&quot;Bohr&quot;</span><span class="p">]</span>
    <span class="n">__RyToK__</span> <span class="o">=</span>  <span class="n">Rydberg</span> <span class="o">/</span> <span class="n">units</span><span class="p">[</span><span class="s2">&quot;kB&quot;</span><span class="p">]</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">Rydberg</span> <span class="o">=</span> <span class="mf">13.605698066</span>
    <span class="n">Bohr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">__A_TO_BOHR__</span>
    <span class="n">__RyToK__</span> <span class="o">=</span> <span class="mf">157887.32400374097</span>

<span class="n">__GPa__</span> <span class="o">=</span> <span class="mf">14710.50763554043</span>

<span class="n">__DEBUG_RHO__</span> <span class="o">=</span> <span class="kc">False</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This source contains the Ensemble class</span>
<span class="sd">It is used to Load and Save info about the ensemble.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">UNITS_DEFAULT</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span>
<span class="n">UNITS_HARTREE</span> <span class="o">=</span> <span class="s2">&quot;hartree&quot;</span>
<span class="n">SUPPORTED_UNITS</span> <span class="o">=</span> <span class="p">[</span><span class="n">UNITS_DEFAULT</span><span class="p">,</span> <span class="n">UNITS_HARTREE</span><span class="p">]</span>


<div class="viewcode-block" id="Ensemble"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble">[docs]</a><span class="k">class</span> <span class="nc">Ensemble</span><span class="p">:</span>
    <span class="n">__debug_index__</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dyn0</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">supercell</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PREPARE THE ENSEMBLE</span>
<span class="sd">        ====================</span>
<span class="sd">        </span>
<span class="sd">        This method initializes and prepares the ensemble.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: To now this works only in the gamma point (dyn0 must be a 1x1x1 supercell)</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            dyn0 : cellconstructor.Phonons.Phonons()</span>
<span class="sd">                This is the dynamical matrix used to generate the ensemble.</span>
<span class="sd">            T0 : float</span>
<span class="sd">                The temperature used to generate the ensemble.</span>
<span class="sd">            supercell: optional, list of int</span>
<span class="sd">                The supercell dimension. If not provided, it will be determined by dyn0</span>
<span class="sd">            **kwargs : any other attribute of the ensemble</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># N is the number of element in the ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">UNITS_DEFAULT</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># If True the frequency smaller than CC.Phonons.__EPSILON_W__ are ignored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="c1"># The original dynamical matrix used to generate the ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span> <span class="o">=</span> <span class="n">dyn0</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T0</span> <span class="o">=</span> <span class="n">T0</span>
        
        <span class="c1"># This is the weight of each configuration in the sampling.</span>
        <span class="c1"># It is updated with the update_weigths function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span> <span class="o">=</span> <span class="n">dyn0</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span> <span class="o">=</span> <span class="n">T0</span>
        
        <span class="c1"># Supercell size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">supercell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">supercell</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">supercell</span>
            
            <span class="c1"># Check if there are inconsistencies</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">dyn0</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">()[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Error, you specified a supercell of </span><span class="si">{}</span><span class="s2">,</span>
<span class="s2">    while from the dynamical matrix provided I expect a supercell of </span><span class="si">{}</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">,</span> <span class="n">dyn0</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dyn0</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">()</span>
        
        <span class="c1"># How many atoms in the supercell</span>
        <span class="n">Nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span> 
        
        <span class="c1"># To avoid to recompute each time the same variables store something usefull here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nsc</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nsc</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>
        
        <span class="c1"># Store also the displacements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nsc</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>
        
        <span class="c1"># A flag that memorize if the ensemble has also the stresses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># A flag for each configuration that check if it possess a force and a stress</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span> <span class="o">=</span> <span class="kc">None</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Get the extra quantities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_quantities</span> <span class="o">=</span> <span class="p">{}</span>


        <span class="c1"># Setup the attribute control</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__total_attributes__</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_attributes</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># This must be the last attribute to be setted</span>


        <span class="c1"># Setup any other keyword given in input (raising the error if not already defined)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>


    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used to set an attribute.</span>
<span class="sd">        It will raise an exception if the attribute does not exists (with a suggestion of similar entries)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        
        <span class="k">if</span> <span class="s2">&quot;fixed_attributes&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__total_attributes__</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">Ensemble</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_attributes</span><span class="p">:</span>
                <span class="n">similar_objects</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span> <span class="n">difflib</span><span class="o">.</span><span class="n">get_close_matches</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__total_attributes__</span><span class="p">))</span>
                <span class="n">ERROR_MSG</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Error, the attribute &#39;</span><span class="si">{}</span><span class="s2">&#39; is not a member of &#39;</span><span class="si">{}</span><span class="s2">&#39;.</span>
<span class="s2">        Suggested similar attributes: </span><span class="si">{}</span><span class="s2"> ?</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>  <span class="n">similar_objects</span><span class="p">)</span>

                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">ERROR_MSG</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">Ensemble</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<div class="viewcode-block" id="Ensemble.convert_units"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.convert_units">[docs]</a>    <span class="k">def</span> <span class="nf">convert_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_units</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        CONVERT ALL THE VARIABLE IN A COHERENT UNIT OF MEASUREMENTS</span>
<span class="sd">        ===========================================================</span>

<span class="sd">        This function is used to jump between several unit of measurement.</span>
<span class="sd">        You should always call this function before processing data assuming</span>
<span class="sd">        a particular kind of units.</span>

<span class="sd">        Supported units are:</span>
<span class="sd">           - &quot;default&quot; : </span>
<span class="sd">               This is the default units. Here the forces are Ry/A displacements and structure are in A</span>
<span class="sd">               Dynamical matrix is in Ry/bohr^2. Mass is in Ry units</span>
<span class="sd">           - &quot;hartree&quot; :</span>
<span class="sd">               Here, everything is stored in Ha units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">           - new_units : string</span>
<span class="sd">               The target units</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if the input is ok</span>
        <span class="k">assert</span> <span class="n">new_units</span> <span class="ow">in</span> <span class="n">SUPPORTED_UNITS</span><span class="p">,</span> <span class="s2">&quot;Error, </span><span class="si">{}</span><span class="s2"> unit is unknown. Try one of </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_units</span><span class="p">,</span> <span class="n">SUPPORTED_UNITS</span><span class="p">)</span>

        <span class="c1"># If we already are in the correct units, ignore it</span>
        <span class="k">if</span> <span class="n">new_units</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="k">if</span> <span class="n">new_units</span> <span class="o">==</span> <span class="n">UNITS_HARTREE</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="n">UNITS_DEFAULT</span><span class="p">:</span>
                <span class="c1"># Convert the dynamical matrix</span>
                <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">q_tot</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">q_tot</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>

                    
                <span class="c1"># Convert the cell shape and the coordinates</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">coords</span> <span class="o">*=</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unit_cell</span> <span class="o">*=</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">coords</span> <span class="o">*=</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unit_cell</span> <span class="o">*=</span> <span class="n">__A_TO_BOHR__</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">/=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span> <span class="c1">#Ry/A -&gt; Ha/bohr</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">/=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">*=</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">/=</span> <span class="mi">2</span> <span class="c1"># Ry -&gt; Ha</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">/=</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">*=</span> <span class="n">__A_TO_BOHR__</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error, I do not know how to convert between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">new_units</span><span class="p">))</span>    
                
        <span class="k">elif</span> <span class="n">new_units</span> <span class="o">==</span> <span class="n">UNITS_DEFAULT</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="n">UNITS_HARTREE</span><span class="p">:</span>
                <span class="c1"># Convert the dynamical matrix</span>
                <span class="k">for</span> <span class="n">iq</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">q_tot</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">q_tot</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">*=</span> <span class="n">__A_TO_BOHR__</span> 
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">*=</span> <span class="n">__A_TO_BOHR__</span>

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span>

                    
                <span class="c1"># Convert the cell shape and the coordinates</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">coords</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unit_cell</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">coords</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unit_cell</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span> <span class="c1"># Ha/bohr -&gt; Ry/A</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">*=</span> <span class="mi">2</span> <span class="c1"># Ha -&gt; Ry</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">*=</span> <span class="mi">2</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">*=</span> <span class="mi">2</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error, I do not know how to convert between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="n">new_units</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error, I do not know anything about this conversion&quot;</span><span class="p">)</span>
                    

        <span class="c1"># Update the units flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">new_units</span></div>

        
<div class="viewcode-block" id="Ensemble.load"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">load_displacements</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">raise_error_on_not_found</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">load_noncomputed_ensemble</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LOAD THE ENSEMBLE</span>
<span class="sd">        =================</span>
<span class="sd">        </span>
<span class="sd">        This function load the ensemble from a standard calculation.</span>
<span class="sd">        </span>
<span class="sd">        The files need to be organized as follows</span>
<span class="sd">        </span>
<span class="sd">        data_dir / scf_populationX_Y.dat</span>
<span class="sd">        data_dir / energies_supercell_populationX.dat </span>
<span class="sd">        data_dir / forces_populationX_Y.dat</span>
<span class="sd">        data_dir / pressures_populationX_Y.dat</span>
<span class="sd">        data_dir / u_populationX_Y.dat</span>
<span class="sd">        </span>
<span class="sd">        X = population</span>
<span class="sd">        Y = the configuration id (starting from 1 to N included, fortran convention)</span>
<span class="sd">        </span>
<span class="sd">        The files scf_population_X_Y.dat must contain the scf file of the structure.</span>
<span class="sd">        It should be in alat units, matching the same alat defined in the starting</span>
<span class="sd">        dynamical matrix.</span>
<span class="sd">        </span>
<span class="sd">        The energies_supercell.dat file must contain the total energy in Ry for</span>
<span class="sd">        each configuration.</span>
<span class="sd">        </span>
<span class="sd">        The forces_populationX_Y contains the </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            data_dir : str</span>
<span class="sd">                The path to the directory containing the ensemble. If you used</span>
<span class="sd">                the fortran sscha.x code it should match the data_dir option of the</span>
<span class="sd">                input file.</span>
<span class="sd">            population : int</span>
<span class="sd">                The info to distinguish between several ensembles generated in the</span>
<span class="sd">                same data_dir. This also should match the correspective property</span>
<span class="sd">                of the fortran sscha.x input file.</span>
<span class="sd">            N : int</span>
<span class="sd">                The dimension of the ensemble. This should match the n_random</span>
<span class="sd">                variable from the fortran sscha.x input file.</span>
<span class="sd">            verbose : bool, optional</span>
<span class="sd">                If true (default false) prints the real timing of the different part</span>
<span class="sd">                during the loading.</span>
<span class="sd">            load_displacement: bool</span>
<span class="sd">                If true the structures are loaded from the u_populationX_Y.dat files,</span>
<span class="sd">                otherwise they are loaded from the scf_populationX_Y.dat files.</span>
<span class="sd">            raise_error_on_not_found : bool</span>
<span class="sd">                If true, raises an error if one force file is missing</span>
<span class="sd">            load_noncomputed_ensemble: bool</span>
<span class="sd">                If True, it allows for loading an ensemble where some of the configurations forces and stresses are missing.</span>
<span class="sd">                Note that it must be compleated before running a SCHA minimization</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A_TO_BOHR</span> <span class="o">=</span> <span class="mf">1.889725989</span>
        
        <span class="c1"># Check if the given data_dir is a real directory</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">data_dir</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error, the given data_dir &#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid directory.&quot;</span> <span class="o">%</span> <span class="n">data_dir</span><span class="p">)</span>
        
        <span class="c1"># Remove the tailoring slash if any</span>
        <span class="k">if</span> <span class="n">data_dir</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="n">data_dir</span> <span class="o">=</span> <span class="n">data_dir</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Load the structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        
        <span class="n">Nat_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span> <span class="o">*</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Initialize the computation of energy and forces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
        
        <span class="c1"># Add a counter to check if all the stress tensors are present</span>
        <span class="n">count_stress</span> <span class="o">=</span> <span class="mi">0</span> 
        
        <span class="c1"># Superstructure</span>
        <span class="n">dyn_supercell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="n">super_structure</span> <span class="o">=</span> <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">structure</span>
        <span class="n">super_fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">dyn_supercell</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">total_t_for_loading</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">total_t_for_sscha_ef</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t_before_for</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="c1"># Load the structure</span>
            <span class="n">structure</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Structure</span><span class="o">.</span><span class="n">Structure</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;scf_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">load_displacements</span><span class="p">:</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">structure</span><span class="o">.</span><span class="n">read_scf</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;scf_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span> <span class="n">alat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">alat</span><span class="p">)</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">total_t_for_loading</span> <span class="o">+=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
                
                <span class="n">structure</span><span class="o">.</span><span class="n">has_unit_cell</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">structure</span><span class="o">.</span><span class="n">unit_cell</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">unit_cell</span>

                <span class="c1"># Get the displacement [ANGSTROM]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_displacement</span><span class="p">(</span><span class="n">super_structure</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Nat_sc</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">structure</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">disp</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;u_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span> <span class="o">/</span><span class="n">__A_TO_BOHR__</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">total_t_for_loading</span> <span class="o">+=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
                
                <span class="n">structure</span><span class="o">.</span><span class="n">coords</span> <span class="o">+=</span> <span class="n">disp</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">disp</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                
            <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">coords</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
            
            
            <span class="c1"># Load forces (Forces are in Ry/bohr, convert them in Ry /A)</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">force_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;forces_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">force_path</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">force_path</span><span class="p">)</span> <span class="o">*</span> <span class="n">A_TO_BOHR</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_error_on_not_found</span><span class="p">:</span>
                    <span class="n">ERROR_MSG</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Error, the file &#39;</span><span class="si">{}</span><span class="s2">&#39; is missing from the ensemble</span>
<span class="s2">       data_dir = &#39;</span><span class="si">{}</span><span class="s2">&#39;</span>
<span class="s2">       please, check better your data.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">force_path</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">ERROR_MSG</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">ERROR_MSG</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            
            <span class="c1"># Load stress</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;pressures_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;pressures_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">total_t_for_loading</span> <span class="o">+=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
            
           
            
<span class="c1">#            print &quot;Loading: config %d:&quot; % i</span>
<span class="c1">#            for j in range(structure.N_atoms):</span>
<span class="c1">#                print &quot;Atom %d&quot; % j</span>
<span class="c1">#                print &quot;u_disp = &quot;, structure.get_displacement(self.dyn_0.structure)[j,:]  *A_TO_BOHR</span>
<span class="c1">#                print &quot;force = &quot;, self.forces[i, j, :] / A_TO_BOHR</span>
<span class="c1">#                print &quot;SCHA force = &quot;, force[j, :] / A_TO_BOHR</span>
<span class="c1">#            </span>
<span class="c1">#            # Debugging stuff</span>
<span class="c1">#            u_disp = structure.get_displacement(self.dyn_0.structure).reshape(3 * structure.N_atoms) * A_TO_BOHR</span>
<span class="c1">#            print &quot;TEST DOBULE:&quot;</span>
<span class="c1">#            print &quot;NORMAL = &quot;, self.dyn_0.dynmats[0].dot(u_disp)</span>
<span class="c1">#            print &quot;INVERSE = &quot;, self.dyn_0.dynmats[0].dot(-u_disp)</span>
                
            
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;[LOAD ENSEMBLE]: time elapsed for the cycle over the configurations:&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_before_for</span><span class="p">)</span>
        
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Load the energy</span>
        <span class="n">total_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;energies_supercell_population</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">population</span><span class="p">)))</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">total_t_for_sscha_ef</span> <span class="o">+=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">total_energies</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span>

        <span class="c1"># Compute the SSCHA energies and forces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span><span class="o">.</span><span class="n">get_energy_forces</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">displacement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">)</span>

        
        <span class="c1"># Setup the initial weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Initialize the q_start</span>
        
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_start</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Manipulate</span><span class="o">.</span><span class="n">GetQ_vectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">,</span> <span class="n">dyn_supercell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_start</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;[LOAD ENSEMBLE]: time elapsed to compute the current q vectors:&quot;</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;[LOAD ENSEMBLE]: time elapsed while loading with numpy:&quot;</span><span class="p">,</span> <span class="n">total_t_for_loading</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;[LOAD ENSEMBLE]: time elapsed for computing sscha energy and forces:&quot;</span><span class="p">,</span> <span class="n">total_t_for_sscha_ef</span><span class="p">)</span>
        

        <span class="n">p_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">p_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check if the forces and stresses are present</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">load_noncomputed_ensemble</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                <span class="n">ERROR_MSG</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Error, the following force files are missing from the ensemble:</span>
<span class="si">{}</span><span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ERROR_MSG</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">ERROR_MSG</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">p_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">p_count</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
                <span class="n">ERROR_MSG</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Error, the following stress files are missing from the ensemble:</span>
<span class="si">{}</span><span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ERROR_MSG</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">ERROR_MSG</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ensemble.load_from_calculator_output"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.load_from_calculator_output">[docs]</a>    <span class="k">def</span> <span class="nf">load_from_calculator_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="p">,</span> <span class="n">out_ext</span> <span class="o">=</span> <span class="s2">&quot;.pwo&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LOAD THE ENSEMBLE FROM A CALCULATION</span>
<span class="sd">        ====================================</span>

<span class="sd">        This subroutine allows to directly load the ensemble from the output files</span>
<span class="sd">        of a calculation. This works and has been tested for quantum espresso,</span>
<span class="sd">        however in principle any output file from an ase supported format </span>
<span class="sd">        should be readed.</span>

<span class="sd">        NOTE: This subroutine requires ASE to be correctly installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            directory : string</span>
<span class="sd">                Path to the directory that contains the output of the calculations</span>
<span class="sd">            out_ext : string</span>
<span class="sd">                The extension of the files that will be readed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">__ASE__</span><span class="p">,</span> <span class="s2">&quot;ASE library required to load from the calculator output file.&quot;</span>

        <span class="c1"># Get all the output file</span>
        <span class="n">output_files</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">out_ext</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_files</span><span class="p">)</span>
        <span class="n">nat_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat_sc</span> <span class="o">*</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Add a counter to check if all the stress tensors are present</span>
        <span class="n">count_stress</span> <span class="o">=</span> <span class="mi">0</span> 
        
        <span class="c1"># Superstructure</span>
        <span class="n">dyn_supercell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="n">super_structure</span> <span class="o">=</span> <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">structure</span>
        <span class="n">super_fc</span> <span class="o">=</span> <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">outf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_files</span><span class="p">):</span>
            <span class="n">ase_struct</span> <span class="o">=</span> <span class="n">ase</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">outf</span><span class="p">)</span>

            <span class="c1"># Get the structure</span>
            <span class="n">structure</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Structure</span><span class="o">.</span><span class="n">Structure</span><span class="p">()</span>
            <span class="n">structure</span><span class="o">.</span><span class="n">generate_from_ase_atoms</span><span class="p">(</span><span class="n">ase_struct</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">coords</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

            <span class="c1"># Get the displacement [ANGSTROM]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_displacement</span><span class="p">(</span><span class="n">super_structure</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">nat_sc</span><span class="p">)</span>

            <span class="c1"># Get the energy</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">ase_struct</span><span class="o">.</span><span class="n">get_potential_energy</span><span class="p">()</span>
            <span class="n">energy</span> <span class="o">/=</span> <span class="n">Rydberg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span>

            <span class="c1"># Get the forces [eV/A -&gt; Ry/A]</span>
            <span class="n">forces</span> <span class="o">=</span> <span class="n">ase_struct</span><span class="o">.</span><span class="n">get_forces</span><span class="p">()</span> <span class="o">/</span> <span class="n">Rydberg</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">forces</span>

            <span class="c1"># Get the stress if any</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">stress</span> <span class="o">=</span> <span class="n">ase_struct</span><span class="o">.</span><span class="n">get_stress</span><span class="p">(</span><span class="n">voigt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1"># eV/A^3 -&gt; Ry/bohr^3</span>
                <span class="n">stress</span> <span class="o">/=</span> <span class="n">Rydberg</span> <span class="o">/</span> <span class="n">Bohr</span><span class="o">**</span><span class="mi">3</span>
                <span class="n">count_stress</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">stress</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="c1"># Get the sscha energy and forces            </span>
            <span class="n">energy</span><span class="p">,</span> <span class="n">force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">get_energy_forces</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">supercell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">,</span> <span class="n">real_space_fc</span><span class="o">=</span><span class="n">super_fc</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">force</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_start</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Manipulate</span><span class="o">.</span><span class="n">GetQ_vectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">,</span> <span class="n">dyn_supercell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_start</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">count_stress</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">False</span></div>
            
            

        
<div class="viewcode-block" id="Ensemble.save"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">use_alat</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SAVE THE ENSEMBLE</span>
<span class="sd">        =================</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        This function saves the ensemble in a way the original fortran SSCHA code can read it.</span>
<span class="sd">        Look at the load function documentation to see clearely how it is saved.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: This method do not save the dynamical matrix used to generate the ensemble (i.e. self.dyn_0)</span>
<span class="sd">        remember to save it separately to really save all the info about the ensemble.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            data_dir : string</span>
<span class="sd">                Path to the directory in which the data will be saved. If it does not exists, it will be created</span>
<span class="sd">            population : int</span>
<span class="sd">                The id of the population, usefull if you want to save more ensemble in the same data_dir without overwriting</span>
<span class="sd">                the data.</span>
<span class="sd">            use_alat : bool</span>
<span class="sd">                If true the scf_populationX_Y.dat files will be saved in alat units, as specified by the dynamical matrix.</span>
<span class="sd">                Also the unit cell will be omitted. This is done to preserve retrocompatibility with ensembles generated by</span>
<span class="sd">                older versions of the sscha code</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A_TO_BOHR</span> <span class="o">=</span> <span class="mf">1.889725989</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c1"># Check if the data dir exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">data_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span>
        
        <span class="c1"># Check if the ensemble has really been initialized</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, the ensemble seems to be not initialized.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Check if the given data_dir is a real directory</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">data_dir</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error, the given data_dir </span><span class="si">%s</span><span class="s2"> is not a valid directory.&quot;</span> <span class="o">%</span> <span class="n">data_dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">data_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span>
        
        <span class="c1"># Remove the tailoring slash if any</span>
        <span class="k">if</span> <span class="n">data_dir</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span>
            <span class="n">data_dir</span> <span class="o">=</span> <span class="n">data_dir</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
        
        <span class="c1"># Save the energies</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s2">&quot;energies_supercell_population</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">population</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">save_qe</span><span class="p">(</span><span class="s2">&quot;dyn_start_population</span><span class="si">%d</span><span class="s2">_&quot;</span> <span class="o">%</span> <span class="n">population</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">save_qe</span><span class="p">(</span><span class="s2">&quot;dyn_end_population</span><span class="si">%d</span><span class="s2">_&quot;</span> <span class="o">%</span> <span class="n">population</span><span class="p">)</span>

        <span class="c1"># Save the displacements with the dynamical matrix used to generate the ensemble</span>
        <span class="c1"># In this way the displacements are computed with the correct dynamical matrix</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>
        
        <span class="c1">#super_dyn = self.dyn_0.GenerateSupercellDyn(self.supercell)</span>
            
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="c1"># Save the forces</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/forces_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">/</span> <span class="n">A_TO_BOHR</span><span class="p">)</span>
            
            <span class="c1"># Save the configurations</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">use_alat</span><span class="p">:</span>
                <span class="n">struct</span><span class="o">.</span><span class="n">save_scf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/scf_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">alat</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">struct</span><span class="o">.</span><span class="n">save_scf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/scf_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

            <span class="n">u_disp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">struct</span><span class="o">.</span><span class="n">N_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="c1"># struct.get_displacement(super_dyn.structure)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/u_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">u_disp</span> <span class="o">*</span> <span class="n">A_TO_BOHR</span><span class="p">)</span>
            
            <span class="c1"># Save the stress tensors if any</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/pressures_population</span><span class="si">%d</span><span class="s2">_</span><span class="si">%d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:])</span>
            
        <span class="c1"># Return back to the old dynamical matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span><span class="n">cd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span></div>
        

<div class="viewcode-block" id="Ensemble.save_bin"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.save_bin">[docs]</a>    <span class="k">def</span> <span class="nf">save_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        FAST SAVE OF THE ENSEMBLE</span>
<span class="sd">        =========================</span>
<span class="sd">        </span>
<span class="sd">        This function is a fast way of saving the ensemble.</span>
<span class="sd">        It is faster and make use of less disk space than the save.</span>
<span class="sd">        The drawback is that can only be opened with numpy</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            data_dir : string</span>
<span class="sd">                path to the folder in which the ensemble is saved</span>
<span class="sd">            population_id : int</span>
<span class="sd">                The id of the population. This can be used to save</span>
<span class="sd">                several ensembles in the same data_dir</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="c1"># Check if the data dir exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">data_dir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span>
        

        <span class="k">if</span> <span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">():</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/energies_pop</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/forces_pop</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">)</span>
            
            <span class="c1"># Save the structures</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/xats_pop</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/stresses_pop</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">save_qe</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/dyn_gen_pop</span><span class="si">%d</span><span class="s2">_&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">))</span></div>
        
<div class="viewcode-block" id="Ensemble.save_enhanced_xyz"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.save_enhanced_xyz">[docs]</a>    <span class="k">def</span> <span class="nf">save_enhanced_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">append_mode</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">stress_key</span> <span class="o">=</span> <span class="s2">&quot;virial&quot;</span><span class="p">,</span> <span class="n">forces_key</span> <span class="o">=</span> <span class="s2">&quot;force&quot;</span><span class="p">,</span> <span class="n">energy_key</span> <span class="o">=</span> <span class="s2">&quot;energy&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the ensemble as an enhanced xyz.</span>

<span class="sd">        This is the default format for training the GAP potentials with quippy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            filename : string</span>
<span class="sd">                Path to the xyz file in which to save.</span>
<span class="sd">            append_mode : bool</span>
<span class="sd">                If true, does not overwrite the previous existing file, but append the ensemble on the bottom.</span>
<span class="sd">                This is the way to concatenate easily more ensembles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Save only if the current processor is the master</span>
        <span class="k">if</span> <span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">():</span>

            <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
                <span class="c1"># Add the number of atoms</span>
                <span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">N_atoms</span><span class="p">))</span>

                <span class="c1"># Prepare the enriched line of xyz with the description of the structure</span>
                <span class="n">info</span> <span class="o">=</span> <span class="s1">&#39;pbc=&quot;T T T&quot; &#39;</span> <span class="c1"># Periodic boundary conditions </span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s1">&#39;Lattice=&quot;</span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1">&quot; &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">unit_cell</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>

                <span class="c1"># Add the energy</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{:.16f}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">energy_key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">Rydberg</span><span class="p">)</span>

                <span class="c1"># Add the virial stress</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=&quot;</span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1"> </span><span class="si">{:20.16f}</span><span class="s1">&quot; &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stress_key</span><span class="p">,</span> <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>

                <span class="c1"># Add the secription of the xyz format</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s1">&#39;Properties=species:S:1:pos:R:3:</span><span class="si">{}</span><span class="s1">:R:3</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">forces_key</span><span class="p">)</span>

                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

                <span class="c1"># Append the structure and the forces</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">N_atoms</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{:20.16f}</span><span class="s2"> </span><span class="si">{:20.16f}</span><span class="s2"> </span><span class="si">{:20.16f}</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]))</span>
                    <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{:20.16f}</span><span class="s2"> </span><span class="si">{:20.16f}</span><span class="s2"> </span><span class="si">{:20.16f}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">Rydberg</span><span class="p">))</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            
            <span class="c1"># Save the work</span>
            <span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">append_mode</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        
        <span class="c1"># Force other processors to wait for the master</span>
        <span class="n">CC</span><span class="o">.</span><span class="n">Settings</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span></div>

<div class="viewcode-block" id="Ensemble.save_raw"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.save_raw">[docs]</a>    <span class="k">def</span> <span class="nf">save_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_directory</span><span class="p">,</span> <span class="n">type_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the ensemble as a set of raw files.</span>

<span class="sd">        This is the default format for training with deepmd</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            filename : string</span>
<span class="sd">                The directory on which to save the ensemble. If it does not exist, it is create.</span>
<span class="sd">                NOTE: this will overwrite any other ensemble saved in raw format in that directory</span>
<span class="sd">            type_dict : dict</span>
<span class="sd">                The dictionary between integers and atomic types. If not provided, it is generated on the spot and returned.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            type_dict : dict</span>
<span class="sd">                The dictionary of the parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">type_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">type_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atm</span><span class="p">)}</span>
        
        <span class="n">inv_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">type_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


        <span class="c1"># Save only if the current processor is the master</span>
        <span class="k">if</span> <span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">root_directory</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">root_directory</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">root_directory</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error, save_raw expects a directory, but &#39;</span><span class="si">{}</span><span class="s2">&#39; is not a directory.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">root_directory</span><span class="p">))</span>

            <span class="c1"># Save the energies</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_directory</span><span class="p">,</span> <span class="s2">&quot;energy.raw&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">*</span> <span class="n">Rydberg</span><span class="p">)</span>

            <span class="c1"># Save the positions</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_directory</span><span class="p">,</span> <span class="s2">&quot;coord.raw&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">nat</span><span class="p">)))</span>

            <span class="c1"># Save the box</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_directory</span><span class="p">,</span> <span class="s2">&quot;box.raw&quot;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unit_cell</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

            <span class="c1"># Save the forces</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_directory</span><span class="p">,</span> <span class="s2">&quot;force.raw&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">))</span> <span class="o">*</span> <span class="n">Rydberg</span><span class="p">)</span>

            <span class="c1"># Save the stress</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_directory</span><span class="p">,</span> <span class="s2">&quot;virial.raw&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span> <span class="o">*</span> <span class="n">__GPa__</span> <span class="o">*</span> <span class="mi">10000</span><span class="p">)</span>

            <span class="c1"># Save the types</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">())</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_directory</span><span class="p">,</span> <span class="s2">&quot;type_map.raw&quot;</span><span class="p">),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">inv_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">type_dict</span><span class="p">))])</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_directory</span><span class="p">,</span> <span class="s2">&quot;type.raw&quot;</span><span class="p">),</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">type_dict</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                
        
        <span class="c1"># Force other processors to wait for the master</span>
        <span class="n">CC</span><span class="o">.</span><span class="n">Settings</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span></div>



        

<div class="viewcode-block" id="Ensemble.load_bin"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.load_bin">[docs]</a>    <span class="k">def</span> <span class="nf">load_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">avoid_loading_dyn</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LOAD THE BINARY ENSEMBLE</span>
<span class="sd">        ========================</span>
<span class="sd">        </span>
<span class="sd">        This function loads the ensemble saved with save_bin(...)</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            data_dir : string</span>
<span class="sd">                The directory containing the ensemble</span>
<span class="sd">            population_id : int</span>
<span class="sd">                The esnemble population identifier.</span>
<span class="sd">            avoid_loading_dyn : bool</span>
<span class="sd">                If true, the dynamical matrix is not loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/energies_pop</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/forces_pop</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/xats_pop</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">))</span>
        
        <span class="c1"># Load the number of configurations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">)</span>
        
        <span class="n">stress_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/stresses_pop</span><span class="si">%d</span><span class="s2">.npy&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stress_path</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stress_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">False</span>
            
        <span class="c1"># Load the original dynamical matrix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">avoid_loading_dyn</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">Phonons</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/dyn_gen_pop</span><span class="si">%d</span><span class="s2">_&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">population_id</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">nqirr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">supercell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">()</span>
            
        <span class="n">super_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="n">Nat_sc</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">N_atoms</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Nat_sc</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Build the structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="mi">3</span><span class="o">*</span><span class="n">Nat_sc</span> <span class="p">)</span>
            
            
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">get_energy_forces</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">displacement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">)</span>

        <span class="c1"># Setup the initial weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Setup that both forces and stresses are not computed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span></div>
        

<div class="viewcode-block" id="Ensemble.init_from_structures"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.init_from_structures">[docs]</a>    <span class="k">def</span> <span class="nf">init_from_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structures</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the ensemble from the given list of structures</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            structures : list of structures</span>
<span class="sd">                The list of structures used to initialize the ensemble</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Perform the standard initialization</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span>
        <span class="n">Nat_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">structures</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span> <span class="o">*</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">):</span>
            <span class="c1"># Get the displacements</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span>
        
        <span class="c1"># TODO:</span>
        <span class="c1"># Here it is useless to generate the supercell dynamical matrix, </span>
        <span class="c1"># it should be replaced by generating the unit cell structure, </span>
        <span class="c1"># But then the get_energy_forces method should provide the correct implementation.</span>
        <span class="n">new_super_dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">new_super_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">Nat_sc</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">get_energy_forces</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">displacement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">)</span>

        
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T0</span>

        <span class="c1"># Setup that both forces and stresses are not computed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ensemble.generate"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">evenodd</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">project_on_modes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GENERATE THE ENSEMBLE</span>
<span class="sd">        =====================</span>
<span class="sd">        </span>
<span class="sd">        This subroutine generates the ensemble from dyn0 and T0 setted when this</span>
<span class="sd">        class is created.</span>
<span class="sd">        You still need to generate the forces for the configurations.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            N : int</span>
<span class="sd">                The number of random configurations to be extracted</span>
<span class="sd">            evenodd : bool, optional</span>
<span class="sd">                If true for each configuration also the opposite is extracted</span>
<span class="sd">            project_on_modes : ndarray(size=(3*nat_sc, nproj)), optional</span>
<span class="sd">                If different from None the displacements are projected on the</span>
<span class="sd">                given modes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">evenodd</span> <span class="ow">and</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, evenodd allowed only with an even number of random structures&quot;</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">Nat_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#super_dyn = self.dyn_0.GenerateSupercellDyn(self.supercell)</span>
        <span class="n">super_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">())</span>

        <span class="n">structures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">evenodd</span><span class="p">:</span>
            <span class="n">structs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">ExtractRandomStructures</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T0</span><span class="p">,</span> <span class="n">project_on_vectors</span> <span class="o">=</span> <span class="n">project_on_modes</span><span class="p">,</span> <span class="n">lock_low_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span><span class="p">)</span>



            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">structs</span><span class="p">):</span>
                <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">new_s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># Get the opposite displacement structure</span>
                <span class="n">new_s</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">super_struct</span><span class="o">.</span><span class="n">coords</span> <span class="o">-</span> <span class="n">new_s</span><span class="o">.</span><span class="n">get_displacement</span><span class="p">(</span><span class="n">super_struct</span><span class="p">)</span>
                <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">structures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">ExtractRandomStructures</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T0</span><span class="p">,</span> <span class="n">project_on_vectors</span> <span class="o">=</span> <span class="n">project_on_modes</span><span class="p">,</span> <span class="n">lock_low_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span><span class="p">)</span>


        <span class="c1"># Enforce all the processors to share the same structures</span>
        <span class="n">structures</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Settings</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_from_structures</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span></div>
        
    <span class="c1"># def get_unwrapped_ensemble(self, subtract_sscha = True, verbose = True):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     This subroutine gets the displacements, forces and stochastic weights of the ensemble</span>
    <span class="c1">#     unwrapping with the symmetries: for each configuraiton, we add all other configurations equivalent by simmetries</span>
        
    <span class="c1">#     NOTE: it works only if SPGLIB is installed</span>

    <span class="c1">#     Parameter</span>
    <span class="c1">#     ---------</span>
    <span class="c1">#         subtract_sscha : bool</span>
    <span class="c1">#             If true (default), instead of the forces, the method returns the forces subtracted by the</span>
    <span class="c1">#             SCHA forces.</span>
    <span class="c1">#         verbose : bool</span>
    <span class="c1">#             If true, the method prints into stdout the timing.</span>

    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#         u_disps : ndarray(size = (n_configs * n_syms, 3*nat), dtype = np.double)</span>
    <span class="c1">#             The displacements of atomic configurations with respect to the average positions</span>
    <span class="c1">#         forces : ndarray(size = (n_configs * n_syms, 3*nat), dtype = np.double)</span>
    <span class="c1">#             The forces that acts on each configuration (subtracted by the SSCHA if requested)</span>
    <span class="c1">#         weights : ndarray(size = n_configs * n_syms, dytpe = no.double)</span>
    <span class="c1">#             The weights of the configurations</span>
    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="c1">#     # First of all, we need to get the symmetries</span>

    <span class="c1">#     # Get the symmetries</span>
    <span class="c1">#     if not __SPGLIB__:</span>
    <span class="c1">#         raise ImportError(&quot;Error, get_unwrapped_ensemble mehtod requires spglib&quot;)</span>

    <span class="c1">#     # Get the symmetries from spglib</span>
    <span class="c1">#     super_structure = self.current_dyn.structure.generate_supercell(self.supercell)</span>
    <span class="c1">#     spglib_syms = spglib.get_symmetry(super_structure.get_ase_atoms())</span>
        
    <span class="c1">#     # Convert them into the cellconstructor format</span>
    <span class="c1">#     cc_syms = CC.symmetries.GetSymmetriesFromSPGLIB(spglib_syms, False)</span>
        
    <span class="c1">#     print(&quot;N syms:&quot;, len(cc_syms))</span>
        
    <span class="c1">#     n_syms = len(cc_syms)</span>
    <span class="c1">#     nat_sc = super_structure.N_atoms</span>
    <span class="c1">#     new_N = n_syms * self.N</span>
        
    <span class="c1">#     # Get the IRT atoms</span>
    <span class="c1">#     irts = np.zeros( (n_syms, nat_sc), dtype = int)</span>
    <span class="c1">#     for i in range(n_syms):</span>
    <span class="c1">#         irts[i, :] = CC.symmetries.GetIRT(super_structure, cc_syms[i]) + 1 # Py -&gt; Fortran indexing</span>



    <span class="c1">#     old_udisps = np.zeros( self.u_disps.shape, dtype = np.double)</span>
    <span class="c1">#     old_forces = np.zeros( self.forces.shape, dtype = np.double)</span>
    <span class="c1">#     new_udisps = np.zeros( (new_N, 3 * nat_sc), dtype = np.double)</span>
    <span class="c1">#     new_forces = np.zeros( (new_N, 3 * nat_sc), dtype = np.double)</span>

    <span class="c1">#     # Convert to crystal coordinates</span>
    <span class="c1">#     t1 = time.time()</span>
    <span class="c1">#     for i in range(self.N):</span>
    <span class="c1">#         v = self.u_disps[i, :].reshape((nat_sc, 3))</span>
    <span class="c1">#         old_udisps[i, :] = CC.Methods.cart_to_cryst(super_structure.unit_cell, v).ravel()</span>


    <span class="c1">#         v = self.forces[i, :].reshape((nat_sc, 3))</span>
    <span class="c1">#         if subtract_sscha:</span>
    <span class="c1">#             v -= self.sscha_forces[i, :].reshape((nat_sc, 3))</span>

    <span class="c1">#         old_forces[i, :] = CC.Methods.cart_to_cryst(super_structure.unit_cell, v).ravel()</span>
    <span class="c1">#     t2 = time.time()</span>

    <span class="c1">#     if verbose:</span>
    <span class="c1">#         print(&quot;Time to convert everything to crystal coordinates: {} s&quot;.format(t2 - t1))</span>

    <span class="c1">#     # Unwrap the ensemble</span>
    <span class="c1">#     new_udisps[:,:] = SCHAMethods.unwrap_ensemble(old_udisps, cc_syms[:3, :3].astype(int), irts, nat_sc, n_syms)</span>
    <span class="c1">#     new_forces[:,:] = SCHAMethods.unwrap_ensemble(old_forces, cc_syms[:3, :3].astype(int), irts, nat_sc, n_syms)</span>


    <span class="c1">#     t3 = time.time()</span>
    <span class="c1">#     if verbose:</span>
    <span class="c1">#         print(&quot;Time to unwrap the ensemble: {} s&quot;.format(t3 - t2))</span>

    <span class="c1">#     # Convert to cartesian coordinates once more</span>
    <span class="c1">#     v = new_udisps.reshape((new_N, nat_sc, 3))</span>
    <span class="c1">#     new_udisps = CC.Methods.cryst_to_cart(super_structure.unit_cell, v).reshape((new_N, 3 * nat_sc))</span>

    <span class="c1">#     v = new_forces.reshape((new_N, nat_sc, 3))</span>
    <span class="c1">#     new_forces = CC.Methods.cryst_to_cart(super_structure.unit_cell, v).reshape((new_N, 3*nat_sc))</span>

    <span class="c1">#     t4 = time.time()</span>
    <span class="c1">#     if verbose:</span>
    <span class="c1">#         print(&quot;Time to convert back to cartesian: {} s&quot;.format(t4 - t3))</span>

    <span class="c1">#     weights = np.zeros( (new_N), dtype = np.double)</span>
    <span class="c1">#     for i in range(self.N):</span>
    <span class="c1">#         weights[n_syms * i : n_syms * (i + 1)] = self.rho[i]</span>
    <span class="c1">#     t5 = time.time()</span>

    <span class="c1">#     if verbose:</span>
    <span class="c1">#         print(&quot;Time to unwrap the weights: {} s&quot;.format(t5 - t4))</span>

    <span class="c1">#         print(&quot;    overall time of get_unwrapped_ensemble: {} s&quot;.format(t5- t1))</span>

    <span class="c1">#     return new_udisps, new_forces, weights</span>



        
    <span class="k">def</span> <span class="nf">_unwrap_symmetries_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        UNWRAP THE ENSEMBLE</span>
<span class="sd">        ===================</span>
<span class="sd">        </span>
<span class="sd">        This function unwraps the current ensemble by introducing the displacements</span>
<span class="sd">        (and energies and forces) of the symmetric specular configurations.</span>
<span class="sd">        This allows for a simple simmetrization of the odd3 correction.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: stress tensors are not unwrapped!</span>
<span class="sd">        </span>
<span class="sd">        NOTE: This works only if spglib is installed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Get the symmetries</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">__SPGLIB__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Error, unwrap_symmetries mehtod requires spglib to be importable&quot;</span><span class="p">)</span>
            
        <span class="c1"># Get the symmetries from spglib</span>
        <span class="n">super_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="n">spglib_syms</span> <span class="o">=</span> <span class="n">spglib</span><span class="o">.</span><span class="n">get_symmetry</span><span class="p">(</span><span class="n">super_structure</span><span class="o">.</span><span class="n">get_ase_atoms</span><span class="p">())</span>
        
        <span class="c1"># Convert them into the cellconstructor format</span>
        <span class="n">cc_syms</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">GetSymmetriesFromSPGLIB</span><span class="p">(</span><span class="n">spglib_syms</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;N syms:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc_syms</span><span class="p">))</span>
        
        <span class="n">n_syms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cc_syms</span><span class="p">)</span>
        <span class="n">nat_sc</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">N_atoms</span>
        
        <span class="c1"># Get the IRT atoms</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">irts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">n_syms</span><span class="p">,</span> <span class="n">nat_sc</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_syms</span><span class="p">):</span>
            <span class="n">irts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">GetIRT</span><span class="p">(</span><span class="n">super_structure</span><span class="p">,</span> <span class="n">cc_syms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Time elapsed to compute IRTS:&quot;</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        
        <span class="n">new_N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">*</span> <span class="n">n_syms</span>
        <span class="n">u_disps_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">new_N</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">nat_sc</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="n">forces_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">new_N</span><span class="p">,</span> <span class="n">nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="n">rho_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">new_N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">xats_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">new_N</span><span class="p">,</span> <span class="n">nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="n">energies_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">new_N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sscha_energies_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">new_N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sscha_forces_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">new_N</span><span class="p">,</span> <span class="n">nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="n">new_structures</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Config </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_syms</span><span class="p">):</span>

                <span class="n">index</span> <span class="o">=</span> <span class="n">n_syms</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span>
                
                <span class="n">u_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">u_new</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">ApplySymmetryToVector</span><span class="p">(</span><span class="n">cc_syms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u_v</span><span class="p">,</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">,</span> <span class="n">irts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">u_disps_new</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">u_new</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">xats_new</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">coords</span> <span class="o">+</span> <span class="n">u_new</span>
                
                <span class="n">f_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="n">f_new</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">ApplySymmetryToVector</span><span class="p">(</span><span class="n">cc_syms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f_v</span><span class="p">,</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">,</span> <span class="n">irts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">forces_new</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">f_new</span>
                
                <span class="n">f_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>                
                <span class="n">f_new</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">ApplySymmetryToVector</span><span class="p">(</span><span class="n">cc_syms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f_v</span><span class="p">,</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">,</span> <span class="n">irts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
                <span class="n">sscha_forces_new</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">f_new</span>
                
                <span class="n">rho_new</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="n">energies_new</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="n">sscha_energies_new</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                
                <span class="n">tmp_struct</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tmp_struct</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">xats_new</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="n">new_structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_struct</span><span class="p">)</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Time elapsed unwrapping the ensemble:&quot;</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        
        <span class="c1"># Update the ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">new_N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">=</span> <span class="n">u_disps_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">=</span> <span class="n">xats_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="n">new_structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">energies_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">=</span> <span class="n">forces_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">=</span> <span class="n">sscha_energies_new</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">=</span> <span class="n">sscha_forces_new</span>
                
        
        
<div class="viewcode-block" id="Ensemble.update_weights"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.update_weights">[docs]</a>    <span class="k">def</span> <span class="nf">update_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dynamical_matrix</span><span class="p">,</span> <span class="n">newT</span><span class="p">,</span> <span class="n">update_q</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        IMPORTANCE SAMPLING</span>
<span class="sd">        ===================</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        This function updates the importance sampling for the given dynamical matrix.</span>
<span class="sd">        The result is written in the self.rho variable</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            new_dynamical_matrix : CC.Phonons.Phonons()</span>
<span class="sd">                The new dynamical matrix on which you want to compute the averages.</span>
<span class="sd">            new_T : float</span>
<span class="sd">                The new temperature.</span>
<span class="sd">            update_q : bool</span>
<span class="sd">                If false the q_vectors are not updated. This is required for some</span>
<span class="sd">                methods and application, but not for standard minimization.</span>
<span class="sd">                Since it is the most time consuming part, it can be safely avoided. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span> <span class="o">=</span> <span class="n">newT</span>

            
        
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Get the frequencies of the original dynamical matrix</span>
        <span class="n">super_struct0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="c1">#super_dyn = self.dyn_0.GenerateSupercellDyn(self.supercell)</span>

        <span class="n">w_original</span><span class="p">,</span> <span class="n">pols_original</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">DiagonalizeSupercell</span><span class="p">()</span><span class="c1">#super_dyn.DyagDinQ(0)</span>
        
        <span class="c1"># Exclude translations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span><span class="p">:</span>
            <span class="n">trans_original</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_translations</span><span class="p">(</span><span class="n">pols_original</span><span class="p">,</span> <span class="n">super_struct0</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">())</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans_original</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_original</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">__EPSILON_W__</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">w_original</span><span class="p">[</span><span class="o">~</span><span class="n">trans_original</span><span class="p">]</span>

        <span class="c1"># Convert from Ry to Ha and in fortran double precision</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        
        <span class="c1"># Get the a_0</span>
        <span class="n">old_a</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">thermodynamic</span><span class="o">.</span><span class="n">w_to_a</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T0</span><span class="p">)</span>
        
        <span class="c1"># Now do the same for the new dynamical matrix</span>
        <span class="n">super_structure</span> <span class="o">=</span> <span class="n">new_dynamical_matrix</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="c1">#new_super_dyn = new_dynamical_matrix.GenerateSupercellDyn(self.supercell)</span>
        
        <span class="n">w_new</span><span class="p">,</span> <span class="n">pols</span> <span class="o">=</span> <span class="n">new_dynamical_matrix</span><span class="o">.</span><span class="n">DiagonalizeSupercell</span><span class="p">()</span><span class="c1">#new_super_dyn.DyagDinQ(0)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span><span class="p">:</span>
            <span class="n">trans_mask</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_translations</span><span class="p">(</span><span class="n">pols</span><span class="p">,</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_new</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">__EPSILON_W__</span>


        <span class="c1"># Check if the new dynamical matrix satisfies the sum rule</span>
        <span class="n">violating_sum_rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_original</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span><span class="p">:</span>
            <span class="n">violating_sum_rule</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_original</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>


        <span class="k">if</span> <span class="n">violating_sum_rule</span><span class="p">:</span>
            <span class="n">ERR_MSG</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ERROR WHILE UPDATING THE WEIGHTS</span>
<span class="s2">    </span>
<span class="s2">Error, one dynamical matrix does not satisfy the acoustic sum rule.</span>
<span class="s2">       If this problem arises on a sscha run, </span>
<span class="s2">       it may be due to a gradient that violates the sum rule.</span>
<span class="s2">       Please, be sure you are not using a custom gradient function.</span>

<span class="s2">DETAILS OF ERROR:</span>
<span class="s2">    Number of translatinal modes in the original dyn = </span><span class="si">{}</span>
<span class="s2">    Number of translational modes in the target dyn = </span><span class="si">{}</span>
<span class="s2">    (They should be both 3)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_original</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">trans_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))</span>

            <span class="nb">print</span><span class="p">(</span><span class="n">ERR_MSG</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">ERR_MSG</span><span class="p">)</span>

        <span class="n">w</span><span class="o">=</span> <span class="n">w_new</span><span class="p">[</span><span class="o">~</span><span class="n">trans_mask</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">new_a</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">thermodynamic</span><span class="o">.</span><span class="n">w_to_a</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">newT</span><span class="p">)</span>
        
        <span class="n">Nat_sc</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">N_atoms</span>
        
        <span class="c1"># Get the new displacements in the supercell</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">old_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">Nat_sc</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">super_structure</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">old_disps</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">Nat_sc</span><span class="p">))</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">super_struct0</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># for i in range(self.N):</span>
        <span class="c1">#     self.u_disps[i, :] = (self.xats[i, :, :] - super_structure.coords).reshape( 3*Nat_sc )</span>
            
        <span class="c1">#     old_disps[i,:] = (self.xats[i, :, :] - super_dyn.structure.coords).reshape( 3*Nat_sc )</span>
            
        <span class="c1">#     # TODO: this method recomputes the displacements, it is useless since we already have them in self.u_disps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="n">new_dynamical_matrix</span><span class="o">.</span><span class="n">get_energy_forces</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">displacement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">,</span> <span class="n">w_pols</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_new</span><span class="p">,</span> <span class="n">pols</span><span class="p">))</span>

        <span class="n">t4</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        
        <span class="c1"># Convert the q vectors in the Hartree units</span>
        <span class="c1">#old_q = self.q_start * np.sqrt(np.float64(2)) * __A_TO_BOHR__</span>
        <span class="c1">#new_q = self.current_q * np.sqrt(np.float64(2)) * __A_TO_BOHR__</span>
        
        
        <span class="c1">#t1 = time.time()</span>
        <span class="c1">#self.rho = SCHAModules.stochastic.get_gaussian_weight(new_q, old_q, new_a, old_a)</span>
        <span class="c1">#t2 = time.time()</span>
        
        <span class="k">if</span> <span class="n">__DEBUG_RHO__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; ==== [UPDATE RHO DEBUGGING] ==== &quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; INPUT INFO: &quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;rho_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; rho saved in &quot;</span><span class="p">,</span> <span class="s2">&quot;rho_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
        
        
        <span class="c1"># Get the covariance matrices of the ensemble</span>
        <span class="n">ups_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">new_dynamical_matrix</span><span class="o">.</span><span class="n">GetUpsilonMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span> <span class="n">w_pols</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_new</span><span class="p">,</span> <span class="n">pols</span><span class="p">)))</span>
        <span class="n">ups_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">GetUpsilonMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T0</span><span class="p">,</span> <span class="n">w_pols</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_original</span><span class="p">,</span> <span class="n">pols_original</span><span class="p">)))</span>

        <span class="c1"># Get the normalization ratio</span>
        <span class="c1">#norm = np.sqrt(np.abs(np.linalg.det(ups_new) / np.linalg.det(ups_old))) </span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span> <span class="n">old_a</span> <span class="o">/</span> <span class="n">new_a</span><span class="p">)</span>

        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Time elapsed to prepare the rho update:&quot;</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; (of which to diagonalize and prepare the structure: </span><span class="si">%.4f</span><span class="s2"> s)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t3</span><span class="o">-</span><span class="n">t1</span><span class="p">))</span>
        <span class="nb">print</span> <span class="p">(</span> <span class="s2">&quot;(of which to update sscha energies and forces: </span><span class="si">%.4f</span><span class="s2"> s)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t4</span><span class="o">-</span><span class="n">t3</span><span class="p">))</span>
        <span class="nb">print</span> <span class="p">(</span> <span class="s2">&quot;(of which computing the Upsilon matrix: </span><span class="si">%.4f</span><span class="s2"> s)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t4</span><span class="p">))</span>
        
        <span class="n">rho_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span> 
        <span class="k">if</span> <span class="n">__DEBUG_RHO__</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Norm factor:&quot;</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">v_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ups_new</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">v_old</span> <span class="o">=</span> <span class="n">old_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ups_old</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">old_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span><span class="o">**</span><span class="mi">2</span>

            <span class="k">if</span> <span class="n">__DEBUG_RHO__</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CONF </span><span class="si">{}</span><span class="s2"> | displacement = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v_new</span> <span class="o">-</span> <span class="n">v_old</span><span class="p">))</span>
            <span class="n">rho_tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">v_new</span> <span class="o">-</span> <span class="n">v_old</span><span class="p">)</span> <span class="p">)</span>
        <span class="c1"># Lets try to use this one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">rho_tmp</span>

        <span class="c1">#print(&quot;\n&quot;.join([&quot;%8d) %16.8f&quot; % (i+1, r) for i, r in enumerate(self.rho)]))</span>
        
        <span class="c1">#np.savetxt(&quot;upsilon_%05d.dat&quot; % self.__debug_index__, ups_new)</span>
        <span class="c1">#np.savetxt(&quot;d_upsilon_%05d.dat&quot; % self.__debug_index__, dups)</span>

        
        <span class="c1">#print &quot;RHO:&quot;, self.rho</span>
        
        <span class="c1">#for i in range(self.N):</span>
            <span class="c1"># Get the new displacement</span>
            <span class="c1">#self.u_disps[i, :] = self.structures[i].get_displacement(new_super_dyn.structure).reshape(3 * new_super_dyn.structure.N_atoms)</span>
            <span class="c1">#self.u_disps[i, :] = (self.xats[i, :, :] - super_structure.coords).reshape( 3*Nat_sc )</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1">#print( &quot;Time elapsed to update weights the sscha energies, forces and displacements:&quot;, t1 - t3, &quot;s&quot;)</span>
        <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;(of which to update the weights):&quot;</span><span class="p">,</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span> <span class="o">=</span> <span class="n">new_dynamical_matrix</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; | to copy the dynamical matrix: </span><span class="si">{}</span><span class="s2"> s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">))</span>
        
        
        <span class="k">if</span> <span class="n">__DEBUG_RHO__</span><span class="p">:</span>
            <span class="n">new_dynamical_matrix</span><span class="o">.</span><span class="n">save_qe</span><span class="p">(</span><span class="s2">&quot;ud_</span><span class="si">%05d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; new_dynmat saved in ud_</span><span class="si">%05d</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; new_T : &quot;</span><span class="p">,</span> <span class="n">newT</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; old_T : &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T0</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; supercell :&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">save_qe</span><span class="p">(</span><span class="s2">&quot;sd_</span><span class="si">%05d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; starting dyn saved in sd_</span><span class="si">%05d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; old_a:&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%16.8f</span><span class="s2">&quot;</span> <span class="o">%</span>  <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">old_a</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; new_a:&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%16.8f</span><span class="s2">&quot;</span> <span class="o">%</span>  <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_a</span><span class="p">]))</span>
            <span class="c1">#np.savetxt(&quot;old_q_%05d.dat&quot; %self.__debug_index__, old_q)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; old_q saved in &quot;</span><span class="p">,</span> <span class="s2">&quot;old_q_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="c1">#np.savetxt(&quot;new_q_%05d.dat&quot; %self.__debug_index__, new_q)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; new_q saved in &quot;</span><span class="p">,</span> <span class="s2">&quot;new_q_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span> <span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; u_disps saved in &quot;</span><span class="p">,</span> <span class="s2">&quot;u_disps_%05.dat&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;u_disps_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">)</span>
            
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; The last rho in&quot;</span><span class="p">,</span> <span class="s2">&quot;rho_last_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;rho_last_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; The other rho kind saved in&quot;</span><span class="p">,</span> <span class="s2">&quot;other_rho_kind_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span>  <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;other_rho_kind_</span><span class="si">%05d</span><span class="s2">.dat&quot;</span>  <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span><span class="p">,</span> <span class="n">rho_tmp</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; The KL according to other rho kind:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rho_tmp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rho_tmp</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__debug_index__</span> <span class="o">+=</span> <span class="mi">1</span></div>
            
            
        
        
        
<div class="viewcode-block" id="Ensemble.get_effective_sample_size"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_effective_sample_size">[docs]</a>    <span class="k">def</span> <span class="nf">get_effective_sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the Kong-Liu effective sample size with the given importance sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">sum_rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">))</span>
        <span class="n">sum_rho2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">kl</span> <span class="o">=</span> <span class="n">sum_rho</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">sum_rho2</span>
        <span class="k">return</span> <span class="n">kl</span></div>
    
<div class="viewcode-block" id="Ensemble.get_average_energy"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_average_energy">[docs]</a>    <span class="k">def</span> <span class="nf">get_average_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtract_sscha</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET ENERGY</span>
<span class="sd">        ==========</span>
<span class="sd">        </span>
<span class="sd">        This is the average of the energy</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \\left&lt; E\\right&gt; = \\frac{1}{N} \\sum_{i = 1}^{N} E_i \\rho_i</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        where :math:`\\rho_i` is the ratio between the probability of extracting the configuration $i$</span>
<span class="sd">        with the current dynamical matrix and with the dynamical matrix used to extract the ensemble.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            subtract_sscha : bool, optional, default False</span>
<span class="sd">                If true, the average difference of energy respect to the sscha one is returned. This</span>
<span class="sd">                is good, because you can compute analytically the sscha energy and sum it on an infinite</span>
<span class="sd">                ensembe. Do in this way to suppress the stochastic noise.</span>
<span class="sd">            return_error : bool, optional, default False</span>
<span class="sd">                If true also the error is returned as a second value</span>
<span class="sd">                </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Example where ensemble is a correctly initialized self variable</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; energy = ensemble.get_average_energy()</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        The following example return also the stochastic error</span>
<span class="sd">        &gt;&gt;&gt; energy, error_on_energy = ensemble.get_average_energy(return_error = True)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">value2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">e_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">e_energy</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">subtract_sscha</span><span class="p">:</span>
            <span class="n">e_energy</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">[:]</span>

        <span class="c1"># Compute the error using the Fortran Module</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">stochastic</span><span class="o">.</span><span class="n">average_error_weight</span><span class="p">(</span><span class="n">e_energy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="s2">&quot;err_yesrho&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_error</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="n">error</span>
        <span class="k">return</span> <span class="n">value</span></div>
     
<div class="viewcode-block" id="Ensemble.get_average_forces"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_average_forces">[docs]</a>    <span class="k">def</span> <span class="nf">get_average_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_error</span><span class="p">,</span> <span class="n">in_unit_cell</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET FORCES</span>
<span class="sd">        ==========</span>
<span class="sd">        </span>
<span class="sd">        This is the average of the forces that acts on the atoms</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \\left&lt; \\vec F\\right&gt; = \\frac{1}{N} \\sum_{i = 1}^{N}\\vec F_i \\rho_i</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        where :math:`\\rho_i` is the ratio between the probability of extracting the configuration :math:`i`</span>
<span class="sd">        with the current dynamical matrix and with the dynamical matrix used to extract the ensemble.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            - get_error : bool</span>
<span class="sd">                If true the error is also returned (as get_free_energy).</span>
<span class="sd">            - in_unit_cell : bool, optional</span>
<span class="sd">                If True (default True) the mean force is averaged on all the atoms in the supercell,</span>
<span class="sd">                then it returns the forces that acts on the unit cell atoms only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">eforces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span>
        
        <span class="k">if</span> <span class="n">in_unit_cell</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Refold the forces in the unit cell</span>
            <span class="n">super_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
            <span class="n">itau</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">get_itau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># Fort -&gt; Py</span>
            
            <span class="n">nat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
            <span class="n">new_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span>  <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
            
            <span class="c1"># Project in the unit cell the forces</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat</span><span class="p">):</span>
                <span class="c1">#print &quot;%d) ITAU LIST:&quot; % i, itau == i</span>
                <span class="n">new_forces</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eforces</span><span class="p">[:,</span> <span class="n">itau</span><span class="o">==</span><span class="n">i</span><span class="p">,:],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
                <span class="c1">#new_forces[:, i, :] = </span>
            
            <span class="n">eforces</span> <span class="o">=</span> <span class="n">new_forces</span>

        <span class="n">force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i, iab -&gt;ab&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">eforces</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">get_error</span><span class="p">:</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i, iab -&gt;ab&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="p">(</span><span class="n">eforces</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="n">f2</span> <span class="o">-</span> <span class="n">force</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">return</span> <span class="n">force</span><span class="p">,</span> <span class="n">err</span>
        <span class="k">return</span> <span class="n">force</span></div>
    
    
<div class="viewcode-block" id="Ensemble.get_free_energy"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_free_energy">[docs]</a>    <span class="k">def</span> <span class="nf">get_free_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SSCHA FREE ENERGY</span>
<span class="sd">        =================</span>
<span class="sd">        </span>
<span class="sd">        Obtain the SSCHA free energy for the system.</span>
<span class="sd">        This is done by integrating the free energy along the hamiltonians, starting</span>
<span class="sd">        from current_dyn to the real system.</span>
<span class="sd">        </span>
<span class="sd">        The result is in Rydberg</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \\mathcal F = \\mathcal F_0 + \\int_0^1 \\frac{d\\mathcal F_\\lambda}{d\\lambda} d\\lambda</span>
<span class="sd">        </span>
<span class="sd">        Where :math:`\\lambda` is the parameter for the adiabatic integration of the hamiltonian.</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            H(\\lambda) = H_0 + (H - H_0) \\lambda</span>
<span class="sd">        </span>
<span class="sd">        here :math:`H_0` is the sscha harmonic hamiltonian, while :math:`H_1` is the real hamiltonian </span>
<span class="sd">        of the system.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            return_error : bool, optional, default False</span>
<span class="sd">                If true also the error is returned as a second value.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            float</span>
<span class="sd">                The free energy in the current dynamical matrix and at the ensemble temperature</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">free_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetHarmonicFreeEnergy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>
        
        <span class="c1"># We got the F_0 </span>
        <span class="c1"># Now we can compute the free energy difference</span>
        <span class="n">anharmonic_free_energy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">return_error</span><span class="p">:</span>
            <span class="n">anharmonic_free_energy</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_average_energy</span><span class="p">(</span><span class="n">subtract_sscha</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_error</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">anharmonic_free_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_average_energy</span><span class="p">(</span><span class="n">subtract_sscha</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1">#print &quot;Free energy harmonic:&quot;, free_energy</span>
        <span class="c1">#print &quot;Free energy anharmonic:&quot;, anharmonic_free_energy</span>
        <span class="n">free_energy</span> <span class="o">+=</span> <span class="n">anharmonic_free_energy</span>
        
        <span class="k">if</span> <span class="n">return_error</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">free_energy</span><span class="p">,</span> <span class="n">error</span>
        <span class="k">return</span> <span class="n">free_energy</span></div>


<div class="viewcode-block" id="Ensemble.get_free_energy_interpolating"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_free_energy_interpolating">[docs]</a>    <span class="k">def</span> <span class="nf">get_free_energy_interpolating</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_supercell</span><span class="p">,</span> <span class="n">support_dyn_coarse</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">support_dyn_fine</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">error_on_imaginary_frequency</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET THE FREE ENERGY IN A BIGGER CELL</span>
<span class="sd">        ====================================</span>

<span class="sd">        This is a trick to interpolate the free energy in the</span>
<span class="sd">        infinite volume limit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            target_supercell : list (N, N, N)</span>
<span class="sd">               A list of three indices, where N is the dimension</span>
<span class="sd">               of the target supercell on which you want to interpolate.</span>
<span class="sd">            support_dyn[coarse/fine] : Phonons() Optional</span>
<span class="sd">               The harmonic dynamical matrix in the current/target_supercell</span>
<span class="sd">               This is optional, it can be used to achieve a better</span>
<span class="sd">               interpolation. If provided only the difference between</span>
<span class="sd">               the harmonic dyn and the current dyn is interpolated.</span>
<span class="sd">            error_on_imaginary_frequency : bool</span>
<span class="sd">               If Fase (default True) it will ignore imaginary frequencies</span>
<span class="sd">               arising from the interpolation. Otherwise an exception will</span>
<span class="sd">               be raised.</span>
<span class="sd">            return_error : bool</span>
<span class="sd">               As the normal get_free_energy, if this flag is True, the stochastic error is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            free_energy : float</span>
<span class="sd">               The free energy in the unit_cell volume [in Ry]. Note.</span>
<span class="sd">               This free energy is rescaled on the unit cell volume, </span>
<span class="sd">               it is a different behaviour with respect to get_free_energy.</span>
<span class="sd">            error_on free energy : float</span>
<span class="sd">               The stochastic error, it is returned only if requested.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if the support harmonic dyn is of the correct size.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">support_dyn_coarse</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">support_dyn_coarse</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">support_dyn_fine</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">()</span> <span class="o">==</span> <span class="n">target_supercell</span>

        
        <span class="c1"># Interpolate the dynamical matrix</span>
        <span class="n">new_dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">Interpolate</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">(),</span>
                                                <span class="n">target_supercell</span><span class="p">,</span>
                                                <span class="n">support_dyn_coarse</span><span class="p">,</span>
                                                <span class="n">support_dyn_fine</span><span class="p">)</span>

        <span class="c1"># TODO: Allow double interpolation in case of support dyn</span>
        
        <span class="c1"># Get the new harmonic free energy</span>
        <span class="n">harm_fe</span> <span class="o">=</span> <span class="n">new_dyn</span><span class="o">.</span><span class="n">GetHarmonicFreeEnergy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span>
                                                <span class="ow">not</span> <span class="n">error_on_imaginary_frequency</span><span class="p">)</span>
        <span class="n">harm_fe</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">target_supercell</span><span class="p">)</span>

        <span class="c1"># Get the average energy</span>
        <span class="n">av_energy</span><span class="p">,</span> <span class="n">av_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_average_energy</span><span class="p">(</span><span class="n">subtract_sscha</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_error</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="n">av_energy</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">())</span>
        <span class="n">av_error</span> <span class="o">/=</span>  <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">())</span>

        <span class="n">total_free_energy</span> <span class="o">=</span> <span class="n">harm_fe</span> <span class="o">+</span> <span class="n">av_energy</span>

        <span class="k">if</span> <span class="n">return_error</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">total_free_energy</span><span class="p">,</span> <span class="n">av_error</span>
        <span class="k">return</span> <span class="n">total_free_energy</span></div>
                                                
            
    

<div class="viewcode-block" id="Ensemble.get_fc_from_self_consistency"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_fc_from_self_consistency">[docs]</a>    <span class="k">def</span> <span class="nf">get_fc_from_self_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtract_sscha</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SELF CONSISTENT SCHA EQUATION</span>
<span class="sd">        =============================</span>
<span class="sd">        </span>
<span class="sd">        This function evaluate the self consistent scha equation. This can be used</span>
<span class="sd">        to evaluate the goodness of the minimization procedure, as well as an</span>
<span class="sd">        independent minimizer.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \\Phi_{ab} = \\frac 12 \\sum_c \\Upsilon_{ac} \\left&lt; u_c f_a\\right&gt;_{\\Phi}</span>
<span class="sd">            </span>
<span class="sd">        The previous equation is true only if the :math:`\\Phi` matrix is the solution</span>
<span class="sd">        of the SCHA theory. Here :math:`\vec u` are the displacements of the configurations</span>
<span class="sd">        and :math:`f` are the forces of the real system acting on the simulation.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            subtract_sscha : bool, optional</span>
<span class="sd">                This is an optional parameter, if true the forces used to evaluate the </span>
<span class="sd">                new force constant matrix are subtracted by the sscha forces. </span>
<span class="sd">                This means that the result is a gradient of the new matrix with respect </span>
<span class="sd">                to the old one.</span>
<span class="sd">            return_error : bool, optional</span>
<span class="sd">                If true also the stochastic error is returned.</span>
<span class="sd">                </span>
<span class="sd">        Results</span>
<span class="sd">        -------</span>
<span class="sd">            fc : ndarray (3*nat x 3*nat)</span>
<span class="sd">                The real space force constant matrix obtained by the</span>
<span class="sd">                self-consistent equation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        
        <span class="c1"># Get the upsilon matrix</span>
        <span class="n">ups_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetUpsilonMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>
        
        

        <span class="c1"># Get the pseudo-displacements obtained as</span>
        <span class="c1"># v = Upsilon * u = u * Upsilon^T  = u * Upsilon (we use the last to exploit fast indexing array)</span>
        <span class="c1">#vs = np.einsum(&quot;ij,jk&quot;, self.u_disps, ups_mat) </span>
        <span class="n">vs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ups_mat</span><span class="p">)</span> <span class="c1"># This should be faster if BLAS and MKL libraries are available (it is executed in parallel)</span>
        
        <span class="c1"># Build the force vector</span>
        <span class="k">if</span> <span class="n">subtract_sscha</span><span class="p">:</span>
            <span class="n">f_vector</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span><span class="p">))</span>
            
        <span class="c1"># Average the ensemble</span>
        <span class="n">new_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i, ij, ik&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">f_vector</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">new_phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_phi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_phi</span><span class="p">))</span> <span class="o">*</span> <span class="mf">.5</span>

        <span class="c1"># DEBUGGING</span>
        <span class="c1">#np.savetxt(&quot;uf_py.dat&quot;, np.einsum(&quot;i, ij, ik&quot;, self.rho, self.u_disps, f_vector) / np.sum(self.rho), header=&quot; &lt;UF&gt; matrix created by python&quot;)</span>

        
        <span class="c1"># Compute the stochastic error</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">return_error</span><span class="p">):</span>
            <span class="n">delta_new_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i, ij, ik&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">vs</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">f_vector</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span> 
            <span class="n">delta_new_phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta_new_phi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">delta_new_phi</span><span class="p">))</span> <span class="o">*</span> <span class="mf">.5</span> 
            <span class="n">delta_new_phi</span> <span class="o">-=</span> <span class="n">new_phi</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">delta_new_phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta_new_phi</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_phi</span><span class="p">,</span> <span class="n">delta_new_phi</span>
        
        <span class="k">return</span> <span class="n">new_phi</span></div>
    
<div class="viewcode-block" id="Ensemble.get_preconditioned_gradient"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_preconditioned_gradient">[docs]</a>    <span class="k">def</span> <span class="nf">get_preconditioned_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtract_sscha</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_error</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                                    <span class="n">use_ups_supercell</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">preconditioned</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">fast_grad</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SELF CONSISTENT SCHA EQUATION</span>
<span class="sd">        =============================</span>
<span class="sd">        </span>
<span class="sd">        This function evaluate the self consistent scha equation. This can be used</span>
<span class="sd">        to evaluate the goodness of the minimization procedure, as well as an</span>
<span class="sd">        independent minimizer. This is the same as get_fc_from_self_consistency,</span>
<span class="sd">        but works also with supercell</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \\Phi_{ab} = \\sum_c \\upsilon_{ac} \\left&lt; u_c f_a\\right&gt;_{\\Phi}</span>
<span class="sd">            </span>
<span class="sd">        The previous equation is true only if the :math:`\\Phi` matrix is the solution</span>
<span class="sd">        of the SCHA theory. Here :math:`\\vec u` are the displacements of the configurations</span>
<span class="sd">        and :math:`f` are the forces of the real system acting on the simulation.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: It does not takes into account for the symmetrization. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            subtract_sscha : bool, optional</span>
<span class="sd">                This is an optional parameter, if true the forces used to evaluate the </span>
<span class="sd">                new force constant matrix are subtracted by the sscha forces. </span>
<span class="sd">                This means that the result is a gradient of the new matrix with respect </span>
<span class="sd">                to the old one.</span>
<span class="sd">            return_error : bool, optional</span>
<span class="sd">                If true also the stochastic error is returned.</span>
<span class="sd">            use_ups_supercell : bool, optional</span>
<span class="sd">                If true the gradient is computed enterely in real space, and then transformed</span>
<span class="sd">                with fourier in q space. This is computationally heavier, but can be used</span>
<span class="sd">                to test if everything is working correctly. For now this flag </span>
<span class="sd">                is ignored and always True.</span>
<span class="sd">            preconitioned : int, optional</span>
<span class="sd">                If 1 (default) the gradient is returned multiplied by the preconditioned,</span>
<span class="sd">                otherwise it is returned as it should be.</span>
<span class="sd">                </span>
<span class="sd">        Results</span>
<span class="sd">        -------</span>
<span class="sd">            fc : ndarray (nq x 3*nat x 3*nat)</span>
<span class="sd">                The real space force constant matrix obtained by the</span>
<span class="sd">                self-consistent equation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">supercell_dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        
        <span class="c1"># Dyagonalize</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">pols</span> <span class="o">=</span> <span class="n">supercell_dyn</span><span class="o">.</span><span class="n">DyagDinQ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_translations</span><span class="p">(</span><span class="n">pols</span><span class="p">,</span> <span class="n">supercell_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">__EPSILON_W__</span>

        <span class="n">ityp</span> <span class="o">=</span> <span class="n">supercell_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_ityp</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Py to fortran convertion</span>
        <span class="n">mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">supercell_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        
        <span class="n">log_err</span> <span class="o">=</span> <span class="s2">&quot;err_yesrho&quot;</span>
        
        <span class="n">mass</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="n">w</span> <span class="o">/=</span> <span class="mi">2</span>

        <span class="n">nat</span> <span class="o">=</span> <span class="n">supercell_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
        <span class="n">eforces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="n">u_disp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="c1">#print nat</span>
        <span class="k">if</span> <span class="n">subtract_sscha</span><span class="p">:</span>
            <span class="n">eforces</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eforces</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">u_disp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="p">(</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> 
        
        
        <span class="c1"># TODO: This may be dangerous</span>
        <span class="n">pols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">pols</span><span class="p">)</span>
        
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot; [GRADIENT] Time to prepare the gradient calculation:&quot;</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span><span class="n">t1</span><span class="p">,</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
            

        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fast_grad</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">preconditioned</span><span class="p">:</span>
            <span class="n">grad</span><span class="p">,</span> <span class="n">grad_err</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">get_gradient_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">u_disp</span><span class="p">,</span> <span class="n">eforces</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">pols</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
                                                                <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">ityp</span><span class="p">,</span> <span class="n">log_err</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span>
                                                                <span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mass</span><span class="p">),</span> <span class="n">preconditioned</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad</span><span class="p">,</span> <span class="n">grad_err</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">get_gradient_supercell_new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">u_disp</span><span class="p">,</span> <span class="n">eforces</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">pols</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
                                                                     <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">ityp</span><span class="p">,</span> <span class="n">log_err</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span>
                                                                     <span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mass</span><span class="p">))</span>
        
            
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; [GRADIENT] Time to call the fortran code:&quot;</span><span class="p">,</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
    
        <span class="c1"># If we are at gamma, we can skip this part</span>
        <span class="c1"># Which makes the code faster</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c1"># Perform the fourier transform</span>
            <span class="n">q_grad</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">GetDynQFromFCSupercell</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">),</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">supercell_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
            <span class="n">q_grad_err</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">GetDynQFromFCSupercell</span><span class="p">(</span><span class="n">grad_err</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">),</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">supercell_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nat3</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">grad</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">q_grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nat3</span><span class="p">,</span> <span class="n">nat3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
            <span class="n">q_grad_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q_grad</span><span class="p">)</span>
            <span class="n">q_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grad</span> 
            <span class="n">q_grad_err</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">grad_err</span>

        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; [GRADIENT] Time to get back in fourier space:&quot;</span><span class="p">,</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">return_error</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">q_grad</span><span class="p">,</span> <span class="n">q_grad_err</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">q_grad</span></div>
        
<span class="c1">#        </span>
<span class="c1">#        nat = self.current_dyn.structure.N_atoms</span>
<span class="c1">#        natsc = np.prod(self.supercell) * nat</span>
<span class="c1">#        </span>
<span class="c1">#        f_vector = self.forces</span>
<span class="c1">#        if subtract_sscha:</span>
<span class="c1">#            f_vector -= self.sscha_forces</span>
<span class="c1">#        </span>
<span class="c1">#        f_vector = f_vector.reshape((self.N, 3 * natsc), order = &quot;F&quot;)</span>
<span class="c1">#        </span>
<span class="c1">#        sum_rho = np.sum(self.rho)</span>
<span class="c1">#        </span>
<span class="c1">#        # Get the &lt;u F&gt; matrix</span>
<span class="c1">#        uf_supercell = np.einsum(&quot;i, ij, ik&quot;, self.rho, self.u_disps, f_vector) / sum_rho</span>
<span class="c1">#        </span>
<span class="c1">#        superstructure = self.dyn_0.structure.generate_supercell(self.supercell)</span>
<span class="c1">#        </span>
<span class="c1">#        # Project the &lt;uF&gt; matrix in q space</span>
<span class="c1">#        if not use_ups_supercell:</span>
<span class="c1">#            uf_q = CC.Phonons.GetDynQFromFCSupercell(uf_supercell, np.array(self.dyn_0.q_tot), self.dyn_0.structure, superstructure)</span>
<span class="c1">#        </span>
<span class="c1">#        if return_error:</span>
<span class="c1">#            uf_delta = np.einsum(&quot;i, ij, ik&quot;, self.rho, self.u_disps**2, f_vector**2) / sum_rho</span>
<span class="c1">#            uf_delta -= uf_supercell**2</span>
<span class="c1">#            if not use_ups_supercell:</span>
<span class="c1">#                uf_q_delta = CC.Phonons.GetDynQFromFCSupercell(uf_delta, np.array(self.dyn_0.q_tot), self.dyn_0.structure, superstructure)</span>
<span class="c1">#            </span>
<span class="c1">#        </span>
<span class="c1">#        </span>
<span class="c1">#        # For each q point, get the gradient</span>
<span class="c1">#        nq = len(self.dyn_0.q_tot)</span>
<span class="c1">#        new_phi = np.zeros( (nq, 3 * nat, 3*nat), dtype = np.complex128, order = &quot;C&quot;)</span>
<span class="c1">#            </span>
<span class="c1">#        if return_error:</span>
<span class="c1">#            error_phi = np.zeros( (nq, 3 * nat, 3*nat), dtype = np.complex128, order = &quot;C&quot;)</span>
<span class="c1">#        </span>
<span class="c1">#        if use_ups_supercell:</span>
<span class="c1">#            # Perform the calculation in the supercell</span>
<span class="c1">#            ups_mat = self.current_dyn.GenerateSupercellDyn(self.supercell).GetUpsilonMatrix(self.current_T)</span>
<span class="c1">#            new_phi_sc = ups_mat.dot(uf_supercell)</span>
<span class="c1">#            </span>
<span class="c1">#            # Convert in q space</span>
<span class="c1">#            new_phi = CC.Phonons.GetDynQFromFCSupercell(new_phi_sc, np.array(self.dyn_0.q_tot), self.dyn_0.structure, superstructure)</span>
<span class="c1">#            </span>
<span class="c1">#            if return_error:</span>
<span class="c1">#                error_new_phi_sc = ups_mat.dot(uf_delta)</span>
<span class="c1">#                error_phi = CC.Phonons.GetDynQFromFCSupercell(error_new_phi_sc, np.array(self.dyn_0.q_tot), self.dyn_0.structure, superstructure)</span>
<span class="c1">#        else:</span>
<span class="c1">#            # Perform the calculation in the q space</span>
<span class="c1">#            for iq in range(nq):</span>
<span class="c1">#                ups_mat = self.current_dyn.GetUpsilonMatrix(self.current_T, iq)</span>
<span class="c1">#                </span>
<span class="c1">#                new_phi[iq, :, :] = ups_mat.dot(uf_q[iq,:,:])</span>
<span class="c1">#                if return_error:</span>
<span class="c1">#                    error_phi[iq, :, :] = ups_mat.dot(uf_q_delta[iq,:,:])</span>
<span class="c1">#        </span>
<span class="c1">#        if return_error:</span>
<span class="c1">#            error_phi = np.sqrt(error_phi)</span>
<span class="c1">#            return new_phi, error_phi</span>
        
 <span class="c1">#</span>
    
<div class="viewcode-block" id="Ensemble.get_covmat_from_ensemble"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_covmat_from_ensemble">[docs]</a>    <span class="k">def</span> <span class="nf">get_covmat_from_ensemble</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET THE COVARIANCE STOCASTICALLY</span>
<span class="sd">        ================================</span>
<span class="sd">        </span>
<span class="sd">        This method is for testing, allows to use the ensemble to</span>
<span class="sd">        evaluate the covariance matrix stochastically. It should be equal</span>
<span class="sd">        to the matrix Upsilon^-1 that is obtained with the GetUpsilonMatrix method</span>
<span class="sd">        from the Phonons package.</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \Upsilon^{-1}_{ab} = \left&lt; u_a u_b\right&gt;</span>
<span class="sd">        </span>
<span class="sd">        Results</span>
<span class="sd">        -------</span>
<span class="sd">            cov_mat : 3nat x 3nat, ndarray</span>
<span class="sd">                A numpy matrix of the covariance matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># A C style matrix of double precision real values</span>
        <span class="n">cov_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;i, ij, ik&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">cov_mat</span></div>
    
    
<div class="viewcode-block" id="Ensemble.get_stress_tensor"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_stress_tensor">[docs]</a>    <span class="k">def</span> <span class="nf">get_stress_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_stress</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">add_centroid_contrib</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">use_spglib</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET STRESS TENSOR</span>
<span class="sd">        =================</span>
<span class="sd">        </span>
<span class="sd">        The following subroutine computes the anharmonic stress tensor</span>
<span class="sd">        calling the fortran code get_stress_tensor.</span>
<span class="sd">        Note that the stress tensor is symmetrized to satisfy the cell constraint.</span>
<span class="sd">        </span>
<span class="sd">        NOTE: unit of measure is Ry/bohr^3 to match the quantum espresso one</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            offset_stress : 3x3 matrix, optional</span>
<span class="sd">                An offset stress to be subtracted to the real stress tensor.</span>
<span class="sd">                Usefull if you want to compute just the anharmonic contribution.</span>
<span class="sd">            add_centroid_contrib : bool, optional</span>
<span class="sd">                If true the contribution of the centroid is added. This is always zero when</span>
<span class="sd">                the system is relaxed.</span>
<span class="sd">            use_spglib : bool</span>
<span class="sd">                If true use the spglib library to perform the symmetrization</span>

<span class="sd">        </span>
<span class="sd">        Results</span>
<span class="sd">        -------</span>
<span class="sd">            stress_tensor : 3x3 matrix</span>
<span class="sd">                The anharmonic stress tensor obtained by averaging both the ab-initio</span>
<span class="sd">                stresses and correcting with the sscha non-linearity.</span>
<span class="sd">            err_stress : 3x3 matrix</span>
<span class="sd">                The matrix of the error on the stress tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, the stress tensors are not present in the current ensemble.&quot;</span><span class="p">)</span>
        
        
        <span class="c1"># Get frequencies and polarization vectors</span>
        <span class="n">super_dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="n">wr</span><span class="p">,</span> <span class="n">pols</span> <span class="o">=</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">DyagDinQ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="o">~</span> <span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_translations</span><span class="p">(</span><span class="n">pols</span><span class="p">,</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">__EPSILON_W__</span>

        <span class="n">wr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">wr</span><span class="p">[</span><span class="n">trans</span><span class="p">])</span>
        <span class="n">pols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span> <span class="n">pols</span><span class="p">[:,</span> <span class="n">trans</span><span class="p">])</span>
        
        <span class="n">nat</span> <span class="o">=</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span> 
        
        <span class="c1"># Volume bohr^3</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_volume</span><span class="p">()</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span><span class="o">**</span><span class="mi">3</span>
            
        
        <span class="c1"># Get the correctly shaped polarization vectors</span>
        <span class="n">er</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nat</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wr</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">wr</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat</span><span class="p">):</span>
                <span class="n">er</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pols</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> 
                <span class="n">er</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pols</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> 
                <span class="n">er</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pols</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> 
                
        <span class="c1"># Prepare the displacement in fortran order</span>
        <span class="n">u_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">):</span>
            <span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="p">(</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        
        <span class="n">abinit_stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc -&gt; cba&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        
        <span class="n">stress</span><span class="p">,</span> <span class="n">err_stress</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">get_stress_tensor</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">/</span> <span class="n">__A_TO_BOHR__</span><span class="p">,</span> <span class="n">u_disps</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span><span class="p">,</span> 
                                                           <span class="n">abinit_stress</span><span class="p">,</span> <span class="n">wr</span><span class="p">,</span> <span class="n">er</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="s2">&quot;err_yesrho&quot;</span><span class="p">,</span> 
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">wr</span><span class="p">))</span>    
        
        <span class="c1"># Correct the stress adding the centroid contribution</span>
        <span class="k">if</span> <span class="n">add_centroid_contrib</span><span class="p">:</span>
                
            <span class="n">eforces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Refold the forces in the unit cell</span>
                <span class="n">super_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
                <span class="n">itau</span> <span class="o">=</span> <span class="n">super_structure</span><span class="o">.</span><span class="n">get_itau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># Fort -&gt; Py</span>
                <span class="n">nat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
                <span class="n">new_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span>  <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
                
                <span class="c1"># Project in the unit cell the forces</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat</span><span class="p">):</span>
                    <span class="c1">#print &quot;%d) ITAU LIST:&quot; % i, itau == i</span>
                    <span class="n">new_forces</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eforces</span><span class="p">[:,</span> <span class="n">itau</span><span class="o">==</span><span class="n">i</span><span class="p">,:],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
                    <span class="c1">#new_forces[:, i, :] = </span>
                
                <span class="n">eforces</span> <span class="o">=</span> <span class="n">new_forces</span>
            
            <span class="n">stress_centr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">error_centr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">av_array</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;h, ah&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                                               <span class="n">eforces</span><span class="p">[:,:,</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">av_array</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;h, ah&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">coords</span><span class="p">[:,</span> <span class="n">j</span><span class="p">],</span>
                                                <span class="n">eforces</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">stress_centr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">error_centr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">stochastic</span><span class="o">.</span><span class="n">average_error_weight</span><span class="p">(</span><span class="n">av_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="s2">&quot;err_yesrho&quot;</span><span class="p">)</span>
                    <span class="n">stress_centr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress_centr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">error_centr</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_centr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            
            
<span class="c1">#            f, err_f = self.get_average_forces(True)</span>
<span class="c1">#            stress_centroid = 0.5 * np.einsum( &quot;ai,aj&quot;, self.current_dyn.structure.coords * __A_TO_BOHR__, f) / volume</span>
<span class="c1">#            stress_centroid += np.transpose(stress_centroid)</span>
<span class="c1">#            err_stress_centroid = np.einsum( &quot;ai,aj&quot;, self.current_dyn.structure.coords**2 , err_f**2)</span>
<span class="c1">#            err_stress_centroid = np.sqrt(err_stress_centroid) * __A_TO_BOHR__ / volume</span>
<span class="c1">#            err_stress_centroid = np.sqrt( err_stress_centroid**2 + np.transpose(err_stress_centroid**2))</span>
<span class="c1">#            divideby = np.ones( (3,3)) * 2</span>
<span class="c1">#            divideby[np.eye(3) == 1] = np.sqrt(2)</span>
<span class="c1">#            err_stress_centroid /= divideby</span>

            <span class="n">stress</span> <span class="o">+=</span> <span class="n">stress_centr</span>
            <span class="n">err_stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err_stress</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">error_centr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>


        
        <span class="c1"># Check the offset</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">offset_stress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stress</span> <span class="o">-=</span> <span class="n">offset_stress</span>

        <span class="c1"># Symmetrize the stress tensor</span>
        <span class="n">qe_sym</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">QE_Symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_spglib</span><span class="p">:</span>
            <span class="n">qe_sym</span><span class="o">.</span><span class="n">SetupQPoint</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qe_sym</span><span class="o">.</span><span class="n">SetupFromSPGLIB</span><span class="p">()</span>

        <span class="n">qe_sym</span><span class="o">.</span><span class="n">ApplySymmetryToMatrix</span><span class="p">(</span><span class="n">stress</span><span class="p">,</span> <span class="n">err_stress</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">stress</span><span class="p">,</span> <span class="n">err_stress</span></div>
    
<div class="viewcode-block" id="Ensemble.get_average_stress"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_average_stress">[docs]</a>    <span class="k">def</span> <span class="nf">get_average_stress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET THE AVERAGE STRESS</span>
<span class="sd">        ======================</span>
<span class="sd">        </span>
<span class="sd">        This gets only the ab-initio average of the stress tensor</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">                </span>
<span class="sd">            P_{\\alpha\\beta} = \\left&lt;P_{\\apha\\beta}\\right&gt;</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc, a&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">qe_sym</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">QE_Symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="n">qe_sym</span><span class="o">.</span><span class="n">SetupQPoint</span><span class="p">()</span>
        <span class="n">qe_sym</span><span class="o">.</span><span class="n">ApplySymmetryToMatrix</span><span class="p">(</span><span class="n">stress</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stress</span></div>
        
    
<span class="c1">#     def get_free_energy_gradient_respect_to_dyn(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         FREE ENERGY GRADIENT</span>
<span class="c1">#         ====================</span>
        
<span class="c1">#         Get the free energy gradient respect to the dynamical matrix.</span>
<span class="c1">#         The result is in [Ry/bohr^3] as the dynamical matrix are stored</span>
<span class="c1">#         in [Ry/bohr^2].</span>
        
<span class="c1">#         NOTE: Not working</span>
        
<span class="c1">#         .. math::</span>
            
<span class="c1">#             \\nabla_\\Phi \\mathcal F = -\\sum_{a\\mu} \\left&lt;\\gamma_\\mu^a q_\\mu\\right&gt;</span>
            
<span class="c1">#             \\gamma_\\mu^a = \\frac{e_\\mu^a \\nabla_\\Phi \\ln a_\\mu + \\nabla_\\Phi e_\mu^a}{\\sqrt M_a}(f_a - f^{\\Phi}_a)</span>
            
<span class="c1">#             q_\\mu = \\sum_b \\sqrt M_b e_\\mu^b (R_b - \\mathcal R_b)</span>
            
<span class="c1">#             \\nabla_\\Phi \\ln a_\\mu = \\frac{1}{2\\omega_\\mu a_\\mu} \\frac{\\partial a_\\mu}{\\partial\\omega_\\mu} \\frac{e_\\mu^a e_\\mu^b}{\\sqrt {M_aM_b}}</span>
            
<span class="c1">#             \\nabla_\\Phi e_\mu^c  =\\sum_{\\nu \\neq \\mu} \\frac{e_\\nu^a e_\\mu^b}{\\sqrt {M_aM_b} (\\omega_\\mu^2 - \\omega_\\nu^2)} e_\\nu^c</span>
    
    
<span class="c1">#         NOTE: it works only at gamma.</span>
    
    
<span class="c1">#         Return</span>
<span class="c1">#         ------</span>
<span class="c1">#             A 3Nx3N matrix. The gradient of the free energy (To be symmetrized)</span>
            
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         #K_to_Ry=6.336857346553283e-06</span>
        
<span class="c1">#         #T = self.current_T</span>
<span class="c1">#         # TODO: TO BE TESTED</span>
        
        
<span class="c1"># #        # Get the mass vector</span>
<span class="c1"># #        _m_ = np.zeros(self.dyn_0.structure.N_atoms * 3)</span>
<span class="c1"># #        for i in range(self.current_dyn.structure.N_atoms):</span>
<span class="c1"># #            _m_[ 3*i : 3*i + 3] = self.current_dyn.structure.masses[ self.current_dyn.structure.atoms[i]]</span>
<span class="c1"># #        </span>
<span class="c1"># #        _m_sqrtinv = 1 / np.sqrt(_m_)</span>
        
<span class="c1">#         # Get the frequency and polarization vector of the dynamical matrix</span>
<span class="c1">#         w, pols = self.current_dyn.DyagDinQ(0)</span>
        
        
<span class="c1">#         # Discard translations and convert in Ha units</span>
<span class="c1">#         not_trans = ~CC.Methods.get_translations(pols, self.current_dyn.structure.get_masses_array())</span>
<span class="c1">#         w = np.array(w[not_trans] / 2, dtype = np.float64)</span>
<span class="c1">#         pols = np.real(pols[:, not_trans])</span>
        
<span class="c1">#         #n_modes = len(w)</span>
        
<span class="c1">#         # Convert the q vector into Ha units</span>
<span class="c1">#         q_new = np.array(self.current_q, dtype = np.float64) * np.sqrt(2) * __A_TO_BOHR__</span>
        
<span class="c1">#         # Get the ityp variable </span>
<span class="c1">#         #ityp = self.current_dyn.structure.get_atomic_types()</span>
        
<span class="c1">#         # Get the mass and convert in Ha units</span>
<span class="c1">#         mass = np.array(self.current_dyn.structure.get_masses_array() * 2,</span>
<span class="c1">#                         dtype = np.float64)</span>
        
<span class="c1">#         nat = len(mass)</span>
        
<span class="c1">#         # Prepare the symmetrization</span>
<span class="c1">#         qe_sym = CC.symmetries.QE_Symmetry(self.current_dyn.structure)</span>
<span class="c1">#         qe_sym.SetupQPoint(self.current_dyn.q_tot[0])</span>
        
        
<span class="c1"># #        # Get the a_mu and its derivatives</span>
<span class="c1"># #        a_mu = np.zeros(n_modes, dtype = np.float64)</span>
<span class="c1"># #        da_dw = np.zeros(n_modes, dtype = np.float64)</span>
        
<span class="c1">#         # Use the fortran subroutines</span>
<span class="c1"># #        if T == 0:</span>
<span class="c1"># #            a_mu = 1 / np.sqrt(2* w) </span>
<span class="c1"># #            da_dw = -1 /  np.sqrt(8 * w**3)</span>
<span class="c1"># #        else:            </span>
<span class="c1"># #            beta = 1 / (K_to_Ry*T)</span>
<span class="c1"># #            a_mu = 1 / np.sqrt( np.tanh(beta*w / 2) *2* w) </span>
<span class="c1"># #            da_dw = - (w*beta + np.sinh(w*beta)) / (2 * np.sqrt(2) * w**2 * (np.cosh(beta*w) - 1) * np.sqrt(np.cosh(beta*w / 2) / (np.sinh(beta*w/2) * w)))</span>
<span class="c1"># #            </span>
<span class="c1"># #    </span>

<span class="c1">#         # Print the sscha forces converted</span>
<span class="c1">#         print (&quot;SCHA forces:&quot;)</span>
<span class="c1">#         for i in range(self.N):</span>
<span class="c1">#             for j in range(self.current_dyn.structure.N_atoms):</span>
<span class="c1">#                 print (&quot;Conf\t%d\tAtom\t%d\t&quot; % (i, j), self.sscha_forces[i, j, :]/ (__A_TO_BOHR__))</span>
                
                
<span class="c1">#         # Convert the forces in Ha / bohr units and in the same type as fortran</span>
<span class="c1">#         e_forces = np.array( self.forces - self.sscha_forces, dtype = np.float64, order = &quot;F&quot;) / (2 * __A_TO_BOHR__)</span>
        
<span class="c1">#         # Get df_da</span>
<span class="c1">#         df_da = SCHAModules.anharmonic.get_df_da_nonav(w, w, self.current_T, pols,</span>
<span class="c1">#                                                        e_forces,</span>
<span class="c1">#                                                        q_new, mass, &quot;stat_schappp&quot;)</span>
<span class="c1">#         #print np.shape(e_forces)</span>
<span class="c1">#         # Now get the rest of the derivative</span>
        
<span class="c1">#         df_dfc = np.zeros( np.shape(self.current_dyn.dynmats[0]), dtype = np.float64)</span>
<span class="c1">#         err_df_dfc = np.zeros( np.shape(self.current_dyn.dynmats[0]), dtype = np.float64)</span>
        
<span class="c1">#         # Just to do something good</span>
<span class="c1">#         da_dcr_mat = np.zeros( (nat * 3, nat * 3, len(w)), dtype = np.float64)</span>
        
<span class="c1">#         for x_i in range(self.current_dyn.structure.N_atoms * 3):</span>
<span class="c1">#             for y_i in range(x_i, self.current_dyn.structure.N_atoms * 3):</span>
<span class="c1">#                 da_dcr, de_dcr = SCHAModules.anharmonic.get_da_dcr_and_de_dcr(w, pols, self.current_T,</span>
<span class="c1">#                                                                               mass, x_i+1, y_i+1)</span>
                
<span class="c1">#                 print (&quot;(%d, %d): DA_DCR = &quot; % (x_i+1, y_i+1), da_dcr)</span>
<span class="c1">#                 da_dcr_mat[x_i, y_i, :] = da_dcr</span>
<span class="c1">#                 da_dcr_mat[y_i, x_i, :] = da_dcr</span>
                

<span class="c1">#                 df_dc, delta_df_dc = SCHAModules.anharmonic.get_df_dcoeff_av_new(df_da, da_dcr, e_forces,</span>
<span class="c1">#                                                                                  q_new, mass, de_dcr, </span>
<span class="c1">#                                                                                  self.rho, 1, &quot;err_yesrho&quot;)</span>
<span class="c1">#                 # Fill the matrix</span>
<span class="c1">#                 df_dfc[x_i, y_i] = df_dc</span>
<span class="c1">#                 df_dfc[y_i, x_i] = df_dc</span>
                
<span class="c1">#                 err_df_dfc[x_i, y_i] = delta_df_dc</span>
<span class="c1">#                 err_df_dfc[y_i, x_i] = delta_df_dc</span>
        
<span class="c1">#         # Get the generator</span>
<span class="c1">#         ghr = np.zeros( (3*nat, 3*nat), dtype = np.float64, order = &quot;F&quot;)</span>
<span class="c1">#         ghr[0,0] = 1</span>
<span class="c1">#         # Apply the sum rule</span>
<span class="c1">#         qe_sym.ImposeSumRule(ghr)</span>
<span class="c1">#         # Apply symmetries</span>
<span class="c1">#         qe_sym.SymmetrizeDynQ(ghr, self.current_dyn.q_tot[0])</span>
<span class="c1">#         ghr /= np.sqrt(np.trace(ghr.dot(ghr)))</span>
<span class="c1">#         print (&quot;Generator:&quot;)</span>
<span class="c1">#         print (ghr)</span>

<span class="c1">#         print (&quot;dA/dGhr = &quot;, np.einsum(&quot;ijk, ij&quot;, da_dcr_mat, ghr) )       </span>
        
<span class="c1">#         # Force the symmetrization</span>
<span class="c1">#         qe_sym.ImposeSumRule(df_dfc)</span>
<span class="c1">#         qe_sym.ImposeSumRule(err_df_dfc)</span>
<span class="c1">#         qe_sym.SymmetrizeDynQ(df_dfc, self.current_dyn.q_tot[0])</span>
<span class="c1">#         qe_sym.SymmetrizeDynQ(err_df_dfc, self.current_dyn.q_tot[0])</span>
        
<span class="c1">#         # Convert from [Ha/bohr] in [Ry/bohr]</span>
<span class="c1">#         df_dfc *= 2</span>
<span class="c1">#         err_df_dfc *=  2</span>
        

<span class="c1"># #        # Prepare the w as a matrix</span>
<span class="c1"># #        _w_ = np.tile(w, (n_modes, 1))</span>
<span class="c1"># #        # 1 / (w_mu^2 - w_nu^2)</span>
<span class="c1"># #        one_over_omegamunu = 1 / (_w_**2 - _w_.transpose()**2)</span>
<span class="c1"># #        #one_over_omegamunu *= 1 - np.eye(n_modes) # Remove the therms for mu equal to nu</span>
<span class="c1"># #        one_over_omegamunu[ (_w_ - _w_.transpose()) &lt; __EPSILON__] = 0</span>
<span class="c1"># #        </span>
<span class="c1"># #        #print &quot;freqs:&quot;, w</span>
<span class="c1"># #        #print &quot;w&quot;, _w_</span>
<span class="c1"># #        #print &quot;one_over_omega:&quot;, one_over_omegamunu</span>
<span class="c1"># #                                        </span>
<span class="c1"># #        # Get the derivative of the lna_mu respect to the dynamical matrix</span>
<span class="c1"># #        # Inner product</span>
<span class="c1"># #        d_lna_d_dyn = np.einsum(&quot;i, ai, bi, ci, a, b, c-&gt;abic&quot;, da_dw/(2 * w * a_mu), pols, pols, pols, _m_sqrtinv, _m_sqrtinv, _m_sqrtinv)</span>
<span class="c1"># #        </span>
<span class="c1"># #        # Get the derivative respect to the polarization vector</span>
<span class="c1"># #        d_pol_d_dyn = np.einsum(&quot;ai,bj,ci,ji,a,b,c-&gt;abjc&quot;, pols, pols, pols, one_over_omegamunu, _m_sqrtinv, _m_sqrtinv, _m_sqrtinv)</span>
<span class="c1"># #        </span>
<span class="c1"># #        #print &quot;d_lna:&quot;, d_lna_d_dyn</span>
<span class="c1"># #        #print &quot;d_pol:&quot;, d_pol_d_dyn</span>
<span class="c1"># #        </span>
<span class="c1"># #        pre_sum = d_lna_d_dyn + d_pol_d_dyn</span>
<span class="c1"># #        </span>
<span class="c1"># #        # Get the q vector</span>
<span class="c1"># #        d_F_d_dyn = np.zeros(np.shape(self.current_dyn.dynmats[0]))</span>
<span class="c1"># #        for i in range(self.N):</span>
<span class="c1"># #            # Get the displacements of the structure</span>
<span class="c1"># #            u_disp = self.structures[i].get_displacement(self.current_dyn.structure).reshape(3 * self.current_dyn.structure.N_atoms)</span>
<span class="c1"># #            </span>
<span class="c1"># #            # Get the forces on the configuration</span>
<span class="c1"># #            delta_f = (self.forces[i,:,:] - self.sscha_forces[i,:,:]).reshape(3 * self.current_dyn.structure.N_atoms)</span>
<span class="c1"># #            </span>
<span class="c1"># #            # Get the q vector</span>
<span class="c1"># #            q = np.einsum(&quot;i, ij, i&quot;, np.sqrt(_m_), pols, u_disp)</span>
<span class="c1"># #            </span>
<span class="c1"># #            # Get gamma matrix</span>
<span class="c1"># #            gamma = np.einsum(&quot;abcd, d&quot;, pre_sum, delta_f)</span>
<span class="c1"># #            </span>
<span class="c1"># #            #print &quot;%d) delta_f = &quot; % (i+1), delta_f</span>
<span class="c1"># #            #print &quot;%d) q = &quot; % (i+1), q</span>
<span class="c1"># #            #print &quot;%d) gamma = &quot; % (i+1), gamma</span>
<span class="c1"># #            </span>
<span class="c1"># #            # Contract the gamma matrix and multiply it for the weight</span>
<span class="c1"># #            partial_gradient = - np.einsum(&quot;abc, c&quot;, gamma, q)</span>
<span class="c1"># #            d_F_d_dyn += partial_gradient * self.rho[i]</span>
<span class="c1"># #            </span>
<span class="c1"># #            #print &quot;conf %d | weight %.4e | partial gradient:&quot; % (i, self.rho[i]), partial_gradient</span>
<span class="c1"># #            </span>
<span class="c1"># #            </span>
<span class="c1"># #        # Normalization</span>
<span class="c1"># #        d_F_d_dyn /= np.sum(self.rho)</span>
<span class="c1">#         #print &quot;Grad:&quot;</span>
<span class="c1">#         #for i in range(np.shape(d_F_d_dyn)[0]):</span>
<span class="c1">#         #    print &quot; &quot;.join([&quot;%7.2e&quot; % x for x in list(d_F_d_dyn[i,:])])</span>
        
<span class="c1">#         #TODO: apply symmetries</span>
            
<span class="c1">#         return df_dfc, err_df_dfc</span>


<div class="viewcode-block" id="Ensemble.get_d3_muspace"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_d3_muspace">[docs]</a>    <span class="k">def</span> <span class="nf">get_d3_muspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET V3 IN MODE SPACE</span>
<span class="sd">        ====================</span>

<span class="sd">        This subroutine gets the d3 directly in the space of the modes.</span>

<span class="sd">        ..math::</span>

<span class="sd">            D^{(3)}_{abc} = \sum_{xyz} \frac{\Phi^{(3)}_{xyz} e_a^x e_b^y e_c^z}{\sqrt{m_x m_y m_z}}</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Be shure to have the correct units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">UNITS_DEFAULT</span><span class="p">)</span>

        <span class="n">supersturct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">generate_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>

        <span class="c1"># Convert from A to Bohr the space </span>
        <span class="n">u_disps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
        <span class="n">n_rand</span><span class="p">,</span> <span class="n">n_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">u_disps</span><span class="p">)</span>
        <span class="n">forces</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">n_modes</span><span class="p">)</span>  <span class="o">/</span> <span class="n">__A_TO_BOHR__</span> 

        <span class="n">Ups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetUpsilonMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>
        <span class="n">v_disp</span> <span class="o">=</span> <span class="n">u_disps</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ups</span><span class="p">)</span>

        <span class="c1"># pass in the polarization space</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">pols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">DiagonalizeSupercell</span><span class="p">()</span>

        <span class="c1"># Discard translations</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_translations</span><span class="p">(</span><span class="n">pols</span><span class="p">,</span> <span class="n">supersturct</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">())</span>
        <span class="n">pols</span> <span class="o">=</span> <span class="n">pols</span><span class="p">[:,</span> <span class="o">~</span><span class="n">trans</span><span class="p">]</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">supersturct</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">(),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">pol_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ab, a-&gt;ab&quot;</span><span class="p">,</span> <span class="n">pols</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>

        <span class="n">v_mode</span> <span class="o">=</span> <span class="n">v_disp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pol_vec</span><span class="p">)</span>
        <span class="n">f_mode</span> <span class="o">=</span> <span class="n">forces</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pol_vec</span><span class="p">)</span>

        <span class="c1"># Now compute the d3 as &lt;vvf&gt;</span>
        <span class="n">N_eff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">f_mode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ia, i-&gt;ia&quot;</span><span class="p">,</span> <span class="n">f_mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">d3_noperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ia,ib,ic-&gt;abc&quot;</span><span class="p">,</span> <span class="n">v_mode</span><span class="p">,</span> <span class="n">v_mode</span><span class="p">,</span> <span class="n">f_mode</span><span class="p">)</span>
        <span class="n">d3_noperm</span> <span class="o">/=</span> <span class="o">-</span><span class="n">N_eff</span> <span class="c1"># there is a minus</span>

        <span class="c1"># Apply the permuatations</span>
        <span class="n">d3</span> <span class="o">=</span> <span class="n">d3_noperm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d3</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc-&gt;acb&quot;</span><span class="p">,</span> <span class="n">d3_noperm</span><span class="p">)</span>
        <span class="n">d3</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc-&gt;bac&quot;</span><span class="p">,</span> <span class="n">d3_noperm</span><span class="p">)</span>
        <span class="n">d3</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc-&gt;bca&quot;</span><span class="p">,</span> <span class="n">d3_noperm</span><span class="p">)</span>
        <span class="n">d3</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc-&gt;cab&quot;</span><span class="p">,</span> <span class="n">d3_noperm</span><span class="p">)</span>
        <span class="n">d3</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc-&gt;cba&quot;</span><span class="p">,</span> <span class="n">d3_noperm</span><span class="p">)</span>
        <span class="n">d3</span> <span class="o">/=</span> <span class="mi">6</span>

        <span class="c1"># TODO: symmetrize</span>

        <span class="k">return</span> <span class="n">d3</span></div>


<div class="viewcode-block" id="Ensemble.get_v3_realspace"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_v3_realspace">[docs]</a>    <span class="k">def</span> <span class="nf">get_v3_realspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a testing function that computes the V3 matrix in real space:</span>
<span class="sd">            </span>
<span class="sd">        ..math::</span>
<span class="sd">            </span>
<span class="sd">            \\Phi^{(3)}_{xyz} = - \sum_{pq} \\Upsilon_{xp}\\Upsilon_{yq} \\left&lt;u_pu_q f_z\\\right&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">nat_sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">N_atoms</span>
        <span class="n">Ups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GetUpsilonMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>
        <span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">nat_sc</span><span class="p">))</span>
        
        <span class="c1"># Get the average &lt;uuf&gt;</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">N_eff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">uuf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ix,iy,iz,i&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">uuf</span> <span class="o">/=</span> <span class="n">N_eff</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time elapsed to compute &lt;uuf&gt;:&quot;</span><span class="p">,</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        
        <span class="c1"># Get the v3</span>
        <span class="n">v3</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xp,yq,pqz-&gt;xyz&quot;</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">uuf</span><span class="p">)</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
        <span class="c1"># Symmetrize</span>
        <span class="c1">#v3 = np.einsum(&quot;xyz,xzy,yxz,yzx,zxy,zyx-&gt;xyz&quot;, v3, v3, v3, v3, v3, v3) / 6</span>
        <span class="n">v3</span> <span class="o">-=</span>  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xp,yq,pqz-&gt;xzy&quot;</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">uuf</span><span class="p">)</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
        <span class="n">v3</span> <span class="o">-=</span>  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xp,yq,pqz-&gt;zyx&quot;</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">uuf</span><span class="p">)</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
        <span class="n">v3</span> <span class="o">-=</span>  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xp,yq,pqz-&gt;yxz&quot;</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">uuf</span><span class="p">)</span><span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
        <span class="n">v3</span> <span class="o">-=</span>  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xp,yq,pqz-&gt;zxy&quot;</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">uuf</span><span class="p">)</span><span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
        <span class="n">v3</span> <span class="o">-=</span>  <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xp,yq,pqz-&gt;yzx&quot;</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">Ups</span><span class="p">,</span> <span class="n">uuf</span><span class="p">)</span><span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
        <span class="n">v3</span> <span class="o">/=</span> <span class="mi">6</span>
        <span class="n">t3</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time elapsed to compute v3:&quot;</span><span class="p">,</span> <span class="n">t3</span><span class="o">-</span><span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v3</span></div>

<div class="viewcode-block" id="Ensemble.get_odd_realspace"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_odd_realspace">[docs]</a>    <span class="k">def</span> <span class="nf">get_odd_realspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a testing function to compute the odd3 correction </span>
<span class="sd">        using the real space v3 (similar to the raffaello first implementation)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the dynamical matrix in the supercell</span>
        <span class="n">super_dyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="n">w_sc</span><span class="p">,</span> <span class="n">pols_sc</span> <span class="o">=</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">DyagDinQ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Remove translations</span>
        <span class="n">no_trans_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_translations</span><span class="p">(</span><span class="n">pols_sc</span><span class="p">,</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">())</span>
        <span class="n">w_sc</span> <span class="o">=</span> <span class="n">w_sc</span><span class="p">[</span><span class="n">no_trans_mask</span><span class="p">]</span>
        <span class="n">pols_sc</span> <span class="o">=</span> <span class="n">pols_sc</span><span class="p">[:,</span> <span class="n">no_trans_mask</span><span class="p">]</span>
        
        <span class="c1"># Get phi3</span>
        <span class="n">phi3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_v3_realspace</span><span class="p">()</span>
        
        <span class="c1"># Get Gmunu</span>
        <span class="n">Gmunu</span> <span class="o">=</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">GetGmunu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>
        
        <span class="c1"># Divide the polarization vectors by the mass</span>
        <span class="n">nat_sc</span> <span class="o">=</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
        <span class="n">epol</span> <span class="o">=</span> <span class="n">pols_sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat_sc</span><span class="p">):</span>
            <span class="n">epol</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pols_sc</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        
        <span class="n">first_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xab,ij,ai,bj-&gt;xij&quot;</span><span class="p">,</span> <span class="n">phi3</span><span class="p">,</span> <span class="n">Gmunu</span><span class="p">,</span> <span class="n">epol</span><span class="p">,</span> <span class="n">epol</span><span class="p">)</span>
        <span class="n">second_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ci,dj,cdy-&gt;ijy&quot;</span><span class="p">,</span> <span class="n">epol</span><span class="p">,</span> <span class="n">epol</span><span class="p">,</span> <span class="n">phi3</span><span class="p">)</span>
        <span class="n">odd_correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;xij, ijy-&gt;xy&quot;</span><span class="p">,</span> <span class="n">first_part</span><span class="p">,</span> <span class="n">second_part</span><span class="p">)</span>
        
        <span class="n">fakedyn</span> <span class="o">=</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
        <span class="n">fakedyn</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">odd_correction</span>
        <span class="n">fakedyn</span><span class="o">.</span><span class="n">save_qe</span><span class="p">(</span><span class="s2">&quot;odd_new&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">super_dyn</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">odd_correction</span></div>
        

<div class="viewcode-block" id="Ensemble.get_v3_qspace"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_v3_qspace">[docs]</a>    <span class="k">def</span> <span class="nf">get_v3_qspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET THE PHONON-PHONON SCATTERING ELEMENT</span>
<span class="sd">        ========================================</span>

<span class="sd">        This subroutine computes the 3-body phonon-phonon scatternig within the sscha.</span>
<span class="sd">        It evaluates the vertex where the q phonon splits in a q+k and -k phonon:</span>
<span class="sd">                    </span>
<span class="sd">                  /---&gt; q + k</span>
<span class="sd">           q ____/</span>
<span class="sd">                 \</span>
<span class="sd">                  \---&gt; -k  </span>

<span class="sd">        </span>
<span class="sd">        This computes v3 on the fly in real space.</span>
<span class="sd">        </span>
<span class="sd">        .. math ::</span>

<span class="sd">            V^3_{abc} (q, -q-k, k)</span>

<span class="sd">        Where :math:`a`, :math:`b` and :math:`c` are the atomic indices in the unit cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            q : ndarray(size = 3, dtype = float)</span>
<span class="sd">                The q vector for the v3 compuation V3(q, -q-k, k).</span>
<span class="sd">            k : ndarray(size = 3, dtype = float)</span>
<span class="sd">                The k vector for the v3 computation V3(q, -q-k, k).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            v3 : ndarray( size = (3*nat, 3*nat, 3*nat), dtype = np.complex128)</span>
<span class="sd">                The 3-rank tensor vertext V3(q, -q-k, k) of the phonon-phonon scattering</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Define the q vectors</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="o">-</span><span class="n">q</span> <span class="o">-</span><span class="n">k</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">k</span>

        <span class="n">superdyn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="n">superstruc</span> <span class="o">=</span> <span class="n">superdyn</span><span class="o">.</span><span class="n">structure</span>
        <span class="n">ups_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">superdyn</span><span class="o">.</span><span class="n">GetUpsilonMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">))</span>

        <span class="c1"># Get Upsilon dot u</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ups_mat</span><span class="p">)</span> <span class="o">*</span> <span class="n">__A_TO_BOHR__</span>
        
        <span class="c1"># Get the corrispondance between unit cell and super cell</span>
        <span class="n">itau</span> <span class="o">=</span> <span class="n">superdyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_itau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">nat_sc</span> <span class="o">=</span> <span class="n">superdyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
        <span class="n">nat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span>

        <span class="n">D3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">N_eff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat_sc</span><span class="p">):</span>
            <span class="n">i_uc</span> <span class="o">=</span> <span class="n">itau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># The forces and displacement along this atom</span>
            <span class="n">v_i</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[:,</span> <span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">f_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">f_i</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat_sc</span><span class="p">):</span>
                <span class="n">j_uc</span> <span class="o">=</span> <span class="n">itau</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="n">R1</span> <span class="o">=</span> <span class="n">superstruc</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">struct</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">i_uc</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">R1</span> <span class="o">-=</span> <span class="n">superstruc</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">struct</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">j_uc</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">q1dotR</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R1</span><span class="p">)</span>

                <span class="c1"># Forces and displacement along this atom</span>
                <span class="n">v_j</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[:,</span> <span class="mi">3</span><span class="o">*</span><span class="n">j</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">f_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[:,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> 
                <span class="n">f_j</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>
                

                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat_sc</span><span class="p">):</span>
                    <span class="n">k_uc</span> <span class="o">=</span> <span class="n">itau</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

                    <span class="n">R2</span> <span class="o">=</span> <span class="n">superstruc</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">struct</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">i_uc</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">R2</span> <span class="o">-=</span> <span class="n">superstruc</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">struct</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k_uc</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">q2dotR</span> <span class="o">=</span> <span class="n">q2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R2</span><span class="p">)</span>
                        
                    <span class="c1"># Forces and displacement along this atom</span>
                    <span class="n">v_k</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[:,</span> <span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">f_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> 
                    <span class="n">f_k</span> <span class="o">/=</span> <span class="n">__A_TO_BOHR__</span>

                    <span class="n">fc</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ia,ib,ic,i&quot;</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">v_j</span><span class="p">,</span> <span class="n">f_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
                    <span class="n">fc</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ia,ib,ic,i&quot;</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">f_j</span><span class="p">,</span> <span class="n">v_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
                    <span class="n">fc</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;ia,ib,ic,i&quot;</span><span class="p">,</span> <span class="n">f_i</span><span class="p">,</span> <span class="n">v_j</span><span class="p">,</span> <span class="n">v_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>
                    <span class="n">fc</span> <span class="o">/=</span> <span class="mi">3</span><span class="o">*</span><span class="n">N_eff</span>
                    <span class="n">D3</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i_uc</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">i_uc</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">j_uc</span><span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">j_uc</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">k_uc</span> <span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="n">k_uc</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span> <span class="n">q1dotR</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">q2dotR</span><span class="p">)</span>

                    
        <span class="k">return</span> <span class="n">D3</span></div>


<div class="viewcode-block" id="Ensemble.get_dynamical_bubble"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_dynamical_bubble">[docs]</a>    <span class="k">def</span> <span class="nf">get_dynamical_bubble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">smearing</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET THE DYNAMICAL BUBBLE SELF ENERGY</span>
<span class="sd">        ====================================</span>

<span class="sd">        This function returns the dynamical bubble self-energy:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \Sigma_{af}(q, w) = \sum_{q&#39;q&#39;&#39;}\sum_{bc,\mu\nu} D^{(3)}_{abc} \left(-\frac 1 2 \chi_{\mu\nu}(\omega, q&#39;, q&#39;&#39;)\right) \frac{e_\nu^b e_\mu^c e_\nu^d e_\mu^e}{\sqrt{M_bM_cM_dM_e}} D^{(3)}_{def}</span>

<span class="sd">        </span>
<span class="sd">        NOTE: The integral in the q space is performed over the mesh grid given by the supercell.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            q : vector</span>
<span class="sd">                The q vector to compute the dynamical self energy</span>
<span class="sd">            w : float or array</span>
<span class="sd">                The frequency(ies) to compute the dynamical self-energy</span>

<span class="sd">        Results</span>
<span class="sd">        -------</span>
<span class="sd">            Sigma : ndarray(size = (3*nat, 3*nat), dtype = np.complex128)</span>
<span class="sd">                The dynamical self energy. Note it could be a list of Sigma</span>
<span class="sd">                if the provided frequency is an array</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># Perform the summation over the allowed q points</span>
        <span class="n">q_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">q_tot</span>

        <span class="n">bg</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_reciprocal_vectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">unit_cell</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">()</span>

        <span class="n">nat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>

        <span class="c1"># Extend m to 3*nat</span>
        <span class="c1"># This is a numpy hack: tile creates a replica matrix of m (3xN_nat)</span>
        <span class="c1"># .T: makes a transposition to N_nat x 3 and ravel convert it in a 1d array</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">minvsqrt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># Check how many frequencies has been provided</span>
        <span class="n">N_w</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">N_w</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Initialize the bubble self energy</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">N_w</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sigmas</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigma</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_w</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q_list</span><span class="p">):</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="o">-</span><span class="n">q</span> <span class="o">-</span><span class="n">k</span>

            <span class="c1"># Get the v3 </span>
            <span class="n">d3_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_v3_qspace</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Sum of v3:&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d3_1</span><span class="p">))</span>

            <span class="c1"># Get the phonon-propagator</span>
            <span class="k">if</span> <span class="n">N_w</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bubbles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_w</span><span class="p">):</span>
                    <span class="n">bubbles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">get_phonon_propagator</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">smearing</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bubble</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">get_phonon_propagator</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">smearing</span><span class="p">)</span>

            <span class="c1"># Get the index of k1 to extract the polarization vectors</span>
            <span class="n">k1_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_min_dist_into_cell</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">q_list</span><span class="p">]</span>
            <span class="n">k1_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">k1_dists</span><span class="p">)</span>

            <span class="n">wk</span><span class="p">,</span> <span class="n">polk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">DyagDinQ</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>
            <span class="n">wk1</span><span class="p">,</span> <span class="n">polk1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">DyagDinQ</span><span class="p">(</span><span class="n">k1_i</span><span class="p">)</span>

            <span class="c1"># Get |e&gt;&lt;e| / sqrt(m_a m_b)</span>
            <span class="n">e_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;am,bn, a, b-&gt;abmn&quot;</span><span class="p">,</span> <span class="n">polk1</span><span class="p">,</span> <span class="n">polk</span><span class="p">,</span> <span class="n">minvsqrt</span><span class="p">,</span> <span class="n">minvsqrt</span><span class="p">)</span>

            <span class="c1"># Convert the d3 in the mu basis</span>
            <span class="n">d3_mubasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;abc, bcmn -&gt; amn&quot;</span><span class="p">,</span> <span class="n">d3_1</span><span class="p">,</span> <span class="n">e_mat</span><span class="p">)</span>

            <span class="c1"># Compute the bubble</span>
            <span class="k">if</span> <span class="n">N_w</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_w</span><span class="p">):</span>
                    <span class="n">sigmas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;amn, mn, bmn-&gt;ab&quot;</span><span class="p">,</span> <span class="n">d3_mubasis</span><span class="p">,</span> <span class="n">bubbles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">d3_mubasis</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;amn, mn, bmn-&gt;ab&quot;</span><span class="p">,</span> <span class="n">d3_mubasis</span><span class="p">,</span> <span class="n">bubble</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">d3_mubasis</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">N_w</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigmas</span>
        <span class="k">return</span> <span class="n">sigma</span></div>


<div class="viewcode-block" id="Ensemble.get_free_energy_hessian"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_free_energy_hessian">[docs]</a>    <span class="k">def</span> <span class="nf">get_free_energy_hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_v4</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">get_full_hessian</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> \
        <span class="n">use_symmetries</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET THE FREE ENERGY ODD CORRECTION</span>
<span class="sd">        ==================================</span>

<span class="sd">        This subroutines computes the odd correction</span>
<span class="sd">        to the free energy hessian using the fortran subroutines, as describe in the</span>
<span class="sd">        Bianco paper ...</span>

<span class="sd">        The calculation is performed in the supercell</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            include_v4 : bool</span>
<span class="sd">                If True we include the fourth order force constant matrix.</span>
<span class="sd">                This requires a lot of memory</span>
<span class="sd">            get_full_hessian : bool</span>
<span class="sd">                If True the full hessian matrix is returned, if false, only the correction to</span>
<span class="sd">                the SSCHA dynamical matrix is returned.</span>
<span class="sd">            verbose : bool</span>
<span class="sd">                If true, the third order force constant tensor is written in output [Ha/bohr^3 units].</span>
<span class="sd">                This can be used to interpolate the result on a bigger mesh with cellconstructor. </span>
<span class="sd">            use_symmetries : bool</span>
<span class="sd">                If true, the d3 and d4 are symmetrized in real space.</span>
<span class="sd">                It requires that spglib is installed to detect symmetries in the supercell correctly.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            phi_sc : Phonons()</span>
<span class="sd">                The dynamical matrix of the free energy hessian in (Ry/bohr^2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For now the v4 is not implemented</span>
        <span class="c1">#     if include_v4:</span>
        <span class="c1">#         ERROR_MSG = &quot;&quot;&quot;</span>
        <span class="c1"># Error, the v4 computation has not yet been implemented.</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="c1">#         raise NotImplementedError(ERROR_MSG)</span>

        <span class="c1"># Convert anything into the Ha units</span>
        <span class="c1"># This is needed for the Fortran subroutines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">UNITS_HARTREE</span><span class="p">)</span>

        <span class="c1"># Get the dynamical matrix in the supercell</span>
        <span class="n">dyn_supercell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">pols</span> <span class="o">=</span> <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">DyagDinQ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">thermodynamic</span><span class="o">.</span><span class="n">w_to_a</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>
        

        <span class="n">n_modes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">nat_sc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pols</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Get the polarization vectors in the correct format</span>
        <span class="n">new_pol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nat_sc</span><span class="p">,</span> <span class="n">n_modes</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nat_sc</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_modes</span><span class="p">):</span>
                <span class="n">new_pol</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">pols</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span> <span class="p">:</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">j</span><span class="p">]</span>
        

        <span class="c1"># Get the translational modes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Methods</span><span class="o">.</span><span class="n">get_translations</span><span class="p">(</span><span class="n">pols</span><span class="p">,</span> <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">__EPSILON_W__</span>


        <span class="c1"># Get the atomic types</span>
        <span class="n">ityp</span> <span class="o">=</span> <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_ityp</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">#Py to Fortran indexing</span>
        <span class="n">n_typ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="p">)</span>

        <span class="n">amass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_typ</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">at_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">ityp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">at_type</span><span class="p">)]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">amass</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">at_type</span><span class="p">]</span>

        <span class="c1"># Get the forces and conver in the correct units</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">)</span><span class="c1"># * Bohr </span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">nat_sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="c1">#/ Bohr</span>

        <span class="n">log_err</span> <span class="o">=</span> <span class="s2">&quot;err_yesrho&quot;</span>

        <span class="c1"># Lets call the Fortran subroutine to compute the v3</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Going into d3&quot;</span><span class="p">)</span>
        <span class="n">d3</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">get_v3</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_pol</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">amass</span><span class="p">,</span> <span class="n">ityp</span><span class="p">,</span>
                                <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">log_err</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outside d3&quot;</span><span class="p">)</span>
        

        <span class="c1"># Symmetrize the d3</span>
        <span class="k">if</span> <span class="n">use_symmetries</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Symmetrizing the d3&quot;</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;d3_realspace_nosym.npy&quot;</span><span class="p">,</span> <span class="n">d3</span><span class="p">)</span>
            <span class="n">qe_sym</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">QE_Symmetry</span><span class="p">(</span><span class="n">dyn_supercell</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
            <span class="n">qe_sym</span><span class="o">.</span><span class="n">SetupFromSPGLIB</span><span class="p">()</span>
            <span class="n">qe_sym</span><span class="o">.</span><span class="n">ApplySymmetryToTensor3</span><span class="p">(</span><span class="n">d3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving the third order force constants as d3_realspace_sym.npy [Ha units]&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;d3_realspace_sym.npy&quot;</span><span class="p">,</span> <span class="n">d3</span><span class="p">)</span>

        <span class="c1"># Check if the v4 must be included</span>
        <span class="k">if</span> <span class="n">include_v4</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the v4, this requires some time...&quot;</span><span class="p">)</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">d4</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">get_v4</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_pol</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">amass</span><span class="p">,</span> <span class="n">ityp</span><span class="p">,</span> \
                <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">log_err</span><span class="p">)</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time elapsed to compute the v4: </span><span class="si">{}</span><span class="s2"> s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">))</span>

            <span class="c1"># Symmetrize the v4 </span>
            <span class="k">if</span> <span class="n">use_symmetries</span><span class="p">:</span>
                <span class="n">qe_sym</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">QE_Symmetry</span><span class="p">(</span><span class="n">dyn_supercell</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
                <span class="n">qe_sym</span><span class="o">.</span><span class="n">SetupFromSPGLIB</span><span class="p">()</span>
                <span class="n">qe_sym</span><span class="o">.</span><span class="n">ApplySymmetryToTensor4</span><span class="p">(</span><span class="n">d4</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inside odd straight&quot;</span><span class="p">)</span>
            <span class="n">phi_sc_odd</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">get_odd_straight_with_v4</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">new_pol</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> \
                <span class="n">amass</span><span class="p">,</span> <span class="n">ityp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span> <span class="n">d3</span><span class="p">,</span> <span class="n">d4</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outside odd straight&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only v3</span>
            <span class="c1"># Get the odd correction (In Ha/bohr^2)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Inside odd straight&quot;</span><span class="p">)</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; A = &quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; W = &quot;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; TRANS = &quot;</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; AMASS = &quot;</span><span class="p">,</span> <span class="n">amass</span><span class="p">)</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; ITYP = &quot;</span><span class="p">,</span> <span class="n">ityp</span><span class="p">)</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot; T = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>
            <span class="n">phi_sc_odd</span> <span class="o">=</span> <span class="n">SCHAModules</span><span class="o">.</span><span class="n">get_odd_straight</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">new_pol</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">amass</span><span class="p">,</span> <span class="n">ityp</span><span class="p">,</span> 
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">,</span> <span class="n">d3</span><span class="p">)</span>
                                        
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Outside odd straight.&quot;</span><span class="p">)</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Saving the odd correction (Ha) as phi_odd.npy&quot;</span><span class="p">)</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;phi_odd.npy&quot;</span><span class="p">,</span> <span class="n">phi_sc_odd</span><span class="p">)</span>

                <span class="c1"># Try to save this matrix</span>
                <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi_sc_odd</span> 
                <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">save_qe</span><span class="p">(</span><span class="s2">&quot;SupercellOddDynHa&quot;</span><span class="p">)</span>
        


        <span class="c1"># Lets fourier transform</span>
        <span class="n">dynq_odd</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">Phonons</span><span class="o">.</span><span class="n">GetDynQFromFCSupercell</span><span class="p">(</span><span class="n">phi_sc_odd</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">),</span> 
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">dyn_supercell</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        
        
        <span class="c1"># Convert back the ensemble in Default units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_units</span><span class="p">(</span><span class="n">UNITS_DEFAULT</span><span class="p">)</span>
        <span class="n">dynq_odd</span> <span class="o">*=</span> <span class="mi">2</span> <span class="c1"># Ha/bohr^2 -&gt; Ry/bohr^2</span>

        <span class="c1"># Generate the Phonon structure by including the odd correction</span>
        <span class="n">dyn_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">get_full_hessian</span><span class="p">:</span>
                <span class="n">dyn_hessian</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">+</span> <span class="n">dynq_odd</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dyn_hessian</span><span class="o">.</span><span class="n">dynmats</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">dynq_odd</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> 

        
        <span class="k">return</span> <span class="n">dyn_hessian</span></div>



<div class="viewcode-block" id="Ensemble.compute_ensemble"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.compute_ensemble">[docs]</a>    <span class="k">def</span> <span class="nf">compute_ensemble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">calculator</span><span class="p">,</span> <span class="n">compute_stress</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">stress_numerical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">cluster</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET ENERGY AND FORCES</span>
<span class="sd">        =====================</span>
<span class="sd">        </span>
<span class="sd">        This is the generic function to compute forces and stresses.</span>
<span class="sd">        It can be used both with clusters, and with simple ase calculators</span>
<span class="sd">        </span>
<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">            calculator:</span>
<span class="sd">                The ase calculator</span>
<span class="sd">            compute_stress: bool</span>
<span class="sd">                If true compute the stress</span>
<span class="sd">            stress_numerical : bool</span>
<span class="sd">                Compute the stress tensor with finite difference, </span>
<span class="sd">                this is not possible with clusters</span>
<span class="sd">            cluster: Cluster, optional</span>
<span class="sd">                The cluster in which to send the calculation.</span>
<span class="sd">                If None the calculation is performed on the same computer of</span>
<span class="sd">                the sscha code.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        
        <span class="c1"># Check if the calculator is a cluster</span>
        <span class="n">is_cluster</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cluster</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">is_cluster</span> <span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1"># Check consistency</span>
        <span class="k">if</span> <span class="n">stress_numerical</span> <span class="ow">and</span> <span class="n">is_cluster</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, stress_numerical is not implemented with clusters&quot;</span><span class="p">)</span>
    
        <span class="c1"># Check if not all the calculation needs to be done</span>
        <span class="n">n_calcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">computing_ensemble</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">compute_stress</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Check wheter compute the whole ensemble, or just a small part</span>
        <span class="n">should_i_merge</span> <span class="o">=</span> <span class="kc">False</span> 
        <span class="k">if</span> <span class="n">n_calcs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
            <span class="n">should_i_merge</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">computing_ensemble</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noncomputed</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_noncomputed</span><span class="p">()</span> 

        <span class="k">if</span> <span class="n">is_cluster</span><span class="p">:</span>
            <span class="n">cluster</span><span class="o">.</span><span class="n">compute_ensemble</span><span class="p">(</span><span class="n">computing_ensemble</span><span class="p">,</span> <span class="n">calculator</span><span class="p">,</span> <span class="n">compute_stress</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">computing_ensemble</span><span class="o">.</span><span class="n">get_energy_forces</span><span class="p">(</span><span class="n">calculator</span><span class="p">,</span> <span class="n">compute_stress</span><span class="p">,</span> <span class="n">stress_numerical</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">should_i_merge</span><span class="p">:</span>
            <span class="c1"># Remove the noncomputed ensemble from here, and merge </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">computing_ensemble</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ensemble.merge"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MERGE TWO ENSEMBLES</span>
<span class="sd">        ===================</span>

<span class="sd">        This function will merge two ensembles together. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            other : Ensemble()</span>
<span class="sd">                Another ensemble to be merge with. It must be generated by the same dynamical matrix</span>
<span class="sd">                as this one, otherwise wired things will happen.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">N</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">forces</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">stresses</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">u_disps</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xats</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">energies</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">force_computed</span><span class="p">))</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">rho</span><span class="p">))</span>

        <span class="c1"># Now update everything</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span></div>


<div class="viewcode-block" id="Ensemble.split"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">split_mask</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SPLIT THE ENSEMBLE</span>
<span class="sd">        ==================</span>

<span class="sd">        This method will return an ensemble with only the configurations matched by the split_mask array.</span>
<span class="sd">        NOTE: The original ensemble will remain untouched.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            split_mask : ndarray(size = self.N, dtype = bool)</span>
<span class="sd">                A mask array. It must be of the same size of the number of configurations, </span>
<span class="sd">                and contain a True or False if you want that the corresponding configuration to be included in the</span>
<span class="sd">                splitted ensemble</span>
<span class="sd">        </span>
<span class="sd">        Results</span>
<span class="sd">        -------</span>
<span class="sd">            splitted_ensemble : Ensemble()</span>
<span class="sd">                An ensemble tath will contain only the configurations in the split mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">structs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split_mask</span><span class="p">))[</span><span class="n">split_mask</span><span class="p">]]</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">split_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="n">ens</span> <span class="o">=</span> <span class="n">Ensemble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn_0</span><span class="o">.</span><span class="n">GetSupercell</span><span class="p">())</span>
        <span class="n">ens</span><span class="o">.</span><span class="n">init_from_structures</span><span class="p">(</span><span class="n">structs</span><span class="p">)</span> 
        <span class="n">ens</span><span class="o">.</span><span class="n">force_computed</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="p">[</span><span class="n">split_mask</span><span class="p">]</span>
        <span class="n">ens</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">[</span><span class="n">split_mask</span><span class="p">]</span>
        <span class="n">ens</span><span class="o">.</span><span class="n">energies</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">[</span><span class="n">split_mask</span><span class="p">]</span>
        <span class="n">ens</span><span class="o">.</span><span class="n">forces</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="n">split_mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">ens</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span>
        <span class="n">ens</span><span class="o">.</span><span class="n">ignore_small_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_small_w</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span><span class="p">:</span>
            <span class="n">ens</span><span class="o">.</span><span class="n">stresses</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">[</span><span class="n">split_mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="n">ens</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ens</span></div>


<div class="viewcode-block" id="Ensemble.remove_noncomputed"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.remove_noncomputed">[docs]</a>    <span class="k">def</span> <span class="nf">remove_noncomputed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removed all the incomplete calculation from the ensemble.</span>
<span class="sd">        It may be used to run a minimization even if the ensemble was not completely calculated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">good_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span><span class="p">:</span>
            <span class="n">good_mask</span> <span class="o">=</span> <span class="n">good_mask</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">good_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="n">good_mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>    
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_forces</span><span class="p">[</span><span class="n">good_mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>    
        <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">[</span><span class="n">good_mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>      
        <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">[</span><span class="n">good_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sscha_energies</span><span class="p">[</span><span class="n">good_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xats</span><span class="p">[</span><span class="n">good_mask</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_disps</span><span class="p">[</span><span class="n">good_mask</span><span class="p">,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good_mask</span><span class="p">))[</span><span class="n">good_mask</span><span class="p">]]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="n">good_mask</span><span class="p">]</span>

        <span class="c1"># Check everything and update the weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_T</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ensemble.get_noncomputed"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_noncomputed">[docs]</a>    <span class="k">def</span> <span class="nf">get_noncomputed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get another ensemble with only the non computed configurations.</span>
<span class="sd">        This may be used to resubmit only the non computed values</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">non_mask</span> <span class="o">=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span><span class="p">:</span>
            <span class="n">non_mask</span> <span class="o">=</span> <span class="n">non_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">non_mask</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ensemble.get_energy_forces"><a class="viewcode-back" href="../../apireference.html#sscha.Ensemble.Ensemble.get_energy_forces">[docs]</a>    <span class="k">def</span> <span class="nf">get_energy_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ase_calculator</span><span class="p">,</span> <span class="n">compute_stress</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">stress_numerical</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">skip_computed</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        GET ENERGY AND FORCES FOR THE CURRENT ENSEMBLE</span>
<span class="sd">        ==============================================</span>
<span class="sd">        </span>
<span class="sd">        This subroutine uses the ase calculator to compute the abinitio energies and forces</span>
<span class="sd">        of the self ensemble.</span>
<span class="sd">        This subroutine requires to have ASE installed and properly configured to</span>
<span class="sd">        interface with your favourite ab-initio software.</span>
<span class="sd">        </span>
<span class="sd">                </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            ase_calculator : ase.calculator</span>
<span class="sd">                The ASE interface to the calculator to run the calculation.</span>
<span class="sd">                also a CellConstructor calculator is accepted</span>
<span class="sd">            compute_stress : bool</span>
<span class="sd">                If true, the stress is requested from the ASE calculator. Be shure</span>
<span class="sd">                that the calculator you provide supports stress calculation</span>
<span class="sd">            stress_numerical : bool</span>
<span class="sd">                If the calculator does not support stress, it can be computed numerically</span>
<span class="sd">                by doing finite differences.</span>
<span class="sd">            skip_computed : bool</span>
<span class="sd">                If true the configurations already computed will be skipped. </span>
<span class="sd">                Usefull if the calculation crashed for some reason.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Setup the calculator for each structure</span>
        <span class="n">parallel</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">__MPI__</span><span class="p">:</span>
            <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">()</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">Get_rank</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">parallel</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># Broad cast to all the structures</span>
                <span class="n">structures</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>            
                <span class="n">nat3</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span><span class="o">*</span> <span class="mi">3</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">),</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">N_rand</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


                <span class="c1">#if not Parallel.am_i_the_master():</span>
                <span class="c1">#    self.structures = structures </span>
                <span class="c1">#    self.init_from_structures(structures) # Enforce all the ensembles to have the same structures</span>
                
                <span class="c1"># Setup the label of the calculator</span>
                <span class="c1">#ase_calculator = comm.bcast(ase_calculator, root = 0)   # This broadcasting seems causing some issues on some fortran codes called by python (which may interact with MPI)</span>
                <span class="n">ase_calculator</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s2">&quot;esp_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">rank</span><span class="p">)</span> <span class="c1"># Avoid overwriting the same file</span>
                
                <span class="n">compute_stress</span> <span class="o">=</span> <span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">compute_stress</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

                
                <span class="c1"># Check if the parallelization is correct        </span>
                <span class="k">if</span> <span class="n">N_rand</span> <span class="o">%</span> <span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, for paralelization the ensemble dimension must be a multiple of the processors&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parallel</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">structures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span>
            <span class="n">nat3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span><span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">)</span>
            <span class="n">N_rand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>
            
        <span class="c1"># Only for the master</span>
        
        <span class="c1"># Prepare the energy, forces and stress array</span>
        <span class="c1"># TODO: Correctly setup the number of energies here</span>
            

        <span class="c1"># If an MPI istance is running, split the calculation</span>
        <span class="n">tot_configs</span> <span class="o">=</span> <span class="n">N_rand</span> <span class="o">//</span> <span class="n">size</span>
        <span class="n">remainer</span> <span class="o">=</span> <span class="n">N_rand</span> <span class="o">%</span> <span class="n">size</span>

        <span class="k">if</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="n">remainer</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">rank</span> <span class="o">*</span> <span class="p">(</span><span class="n">tot_configs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">tot_configs</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">rank</span> <span class="o">*</span> <span class="n">tot_configs</span> <span class="o">+</span> <span class="n">remainer</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">tot_configs</span>

        <span class="n">num_confs</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>

        <span class="n">energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">num_confs</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="n">num_confs</span><span class="p">)</span> <span class="o">*</span> <span class="n">nat3</span> <span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_stress</span><span class="p">:</span>
            <span class="n">stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">num_confs</span> <span class="o">*</span> <span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">total_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">N_rand</span> <span class="o">*</span> <span class="n">nat3</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">total_stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">N_rand</span> <span class="o">*</span> <span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_forces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span> <span class="n">N_rand</span> <span class="o">*</span> <span class="n">nat3</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">total_stress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span> <span class="n">N_rand</span> <span class="o">*</span> <span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>

            <span class="c1"># Avoid performing this calculation if already done</span>
            <span class="k">if</span> <span class="n">skip_computed</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">compute_stress</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                            <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
            
            
            <span class="n">struct</span> <span class="o">=</span> <span class="n">structures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#atms = struct.get_ase_atoms()</span>
            
            <span class="c1"># Setup the ASE calculator</span>
            <span class="c1">#atms.set_calculator(ase_calculator)</span>


            <span class="c1"># Print the status</span>
            <span class="k">if</span> <span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">()</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Computing configuration </span><span class="si">%d</span><span class="s2"> out of </span><span class="si">%d</span><span class="s2"> (nat = </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">struct</span><span class="o">.</span><span class="n">N_atoms</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            
            <span class="c1"># Avoid for errors</span>
            <span class="n">run</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">count_fails</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">run</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">CC</span><span class="o">.</span><span class="n">calculators</span><span class="o">.</span><span class="n">get_results</span><span class="p">(</span><span class="n">ase_calculator</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="n">get_stress</span> <span class="o">=</span> <span class="n">compute_stress</span><span class="p">)</span>
                    <span class="n">energy</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">Rydberg</span> <span class="c1"># eV =&gt; Ry</span>
                    <span class="n">forces_</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;forces&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">Rydberg</span>

                    <span class="k">if</span> <span class="n">compute_stress</span><span class="p">:</span>
                        <span class="n">stress</span><span class="p">[</span><span class="mi">9</span><span class="o">*</span><span class="n">i0</span> <span class="p">:</span> <span class="mi">9</span><span class="o">*</span><span class="n">i0</span> <span class="o">+</span> <span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;stress&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">*</span> <span class="n">Bohr</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="n">Rydberg</span>
                    <span class="c1">#energy = atms.get_total_energy() / Rydberg # eV =&gt; Ry</span>
                    <span class="c1"># Get energy, forces (and stress)</span>
                    <span class="c1">#energy = atms.get_total_energy() / Rydberg # eV =&gt; Ry</span>
                    <span class="c1">#forces_ = atms.get_forces() / Rydberg # eV / A =&gt; Ry / A</span>
                    <span class="c1">#if compute_stress:</span>
                    <span class="c1">#    if not stress_numerical:</span>
                    <span class="c1">#        stress[9*i0 : 9*i0 + 9] = -atms.get_stress(False).reshape(9) * Bohr**3 / Rydberg  # ev/A^3 =&gt; Ry/bohr</span>
                    <span class="c1">#    else:</span>
                    <span class="c1">#        stress[9*i0 : 9*i0 + 9] = -ase_calculator.calculate_numerical_stress(atms, voigt = False).ravel()* Bohr**3 / Rydberg </span>
                            
                    <span class="c1"># Copy into the ensemble array</span>
                    <span class="n">energies</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">=</span> <span class="n">energy</span>
                    <span class="n">forces</span><span class="p">[</span><span class="n">nat3</span><span class="o">*</span><span class="n">i0</span> <span class="p">:</span> <span class="n">nat3</span><span class="o">*</span><span class="n">i0</span> <span class="o">+</span> <span class="n">nat3</span><span class="p">]</span> <span class="o">=</span> <span class="n">forces_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="n">nat3</span> <span class="p">)</span>
                    <span class="n">run</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Rerun the job </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">count_fails</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">count_fails</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
                        <span class="n">run</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">struct</span><span class="o">.</span><span class="n">save_scf</span><span class="p">(</span><span class="s2">&quot;error_struct.scf&quot;</span><span class="p">)</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Error in the ASE calculator for more than 5 times</span><span class="se">\n</span><span class="s2">     while computing &#39;error_struct.scf&#39;&quot;</span><span class="p">)</span>
                        <span class="k">raise</span>
            


            <span class="n">i0</span> <span class="o">+=</span> <span class="mi">1</span>
            
            

            
        
        <span class="c1"># Collect all togheter</span>
        
        <span class="k">if</span> <span class="n">parallel</span><span class="p">:</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Allgather</span><span class="p">([</span><span class="n">energies</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">energies</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">])</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Allgather</span><span class="p">([</span><span class="n">forces</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">],</span> <span class="p">[</span><span class="n">total_forces</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">compute_stress</span><span class="p">:</span>
                <span class="n">comm</span><span class="o">.</span><span class="n">Allgather</span><span class="p">([</span><span class="n">stress</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">],</span> <span class="p">[</span><span class="n">total_stress</span><span class="p">,</span> <span class="n">MPI</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">])</span>

            
            <span class="c1">#self.update_weights(self.current_dyn, self.current_T)</span>
            <span class="n">CC</span><span class="o">.</span><span class="n">Settings</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>            

            
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">energies</span> <span class="o">=</span> <span class="n">energies</span>
            <span class="n">total_forces</span> <span class="o">=</span> <span class="n">forces</span>
            <span class="k">if</span> <span class="n">compute_stress</span><span class="p">:</span>
                <span class="n">total_stress</span> <span class="o">=</span> <span class="n">stress</span>
        
        <span class="c1"># Reshape the arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">total_forces</span><span class="p">,</span> <span class="p">(</span><span class="n">N_rand</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">supercell</span><span class="p">),</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_computed</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">compute_stress</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stresses</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">total_stress</span><span class="p">,</span> <span class="p">(</span><span class="n">N_rand</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stress_computed</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_stress</span> <span class="o">=</span> <span class="kc">False</span></div></div>
            
            
        
        
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index1.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Lorenzo Monacelli.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>