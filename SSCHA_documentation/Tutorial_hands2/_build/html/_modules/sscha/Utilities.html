
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sscha.Utilities &#8212; python-sscha 1.2 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sscha.Utilities</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the prefined custom function to</span>
<span class="sd">perform some standard variants of the minimization.</span>

<span class="sd">The function are classified as:</span>
<span class="sd">CGF : custom_gradient_function</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">difflib</span>
<span class="kn">import</span> <span class="nn">cellconstructor</span> <span class="k">as</span> <span class="nn">CC</span>
<span class="kn">import</span> <span class="nn">cellconstructor.Phonons</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">sscha.Parallel</span> <span class="kn">import</span> <span class="n">pprint</span> <span class="k">as</span> <span class="nb">print</span>
<span class="kn">import</span> <span class="nn">sscha.Parallel</span>

<span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">__UTILS_NAMESPACE__</span> <span class="o">=</span> <span class="s2">&quot;utils&quot;</span>
<span class="n">__UTILS_SAVEFREQ_FILENAME__</span> <span class="o">=</span> <span class="s2">&quot;save_freq_filename&quot;</span>
<span class="n">__UTILS_SAVERHO_FILENAME__</span> <span class="o">=</span> <span class="s2">&quot;save_rho_filename&quot;</span>
<span class="n">__UTILS_LOCKMODE_START__</span> <span class="o">=</span> <span class="s2">&quot;mu_lock_start&quot;</span>
<span class="n">__UTILS_LOCKMODE_END__</span> <span class="o">=</span> <span class="s2">&quot;mu_lock_end&quot;</span>
<span class="n">__UTILS_FREEMODE_START__</span> <span class="o">=</span> <span class="s2">&quot;mu_free_start&quot;</span>
<span class="n">__UTILS_FREEMODE_END__</span> <span class="o">=</span> <span class="s2">&quot;mu_free_end&quot;</span>
<span class="n">__UTILS_PROJECT_DYN__</span> <span class="o">=</span> <span class="s2">&quot;project_dyn&quot;</span>
<span class="n">__UTILS_PROJECT_STRUCTURE__</span> <span class="o">=</span> <span class="s2">&quot;project_structure&quot;</span>

<span class="n">__ALLOWED_KEYS__</span> <span class="o">=</span> <span class="p">[</span><span class="n">__UTILS_SAVEFREQ_FILENAME__</span><span class="p">,</span> <span class="n">__UTILS_SAVERHO_FILENAME__</span><span class="p">,</span>
                    <span class="n">__UTILS_LOCKMODE_START__</span><span class="p">,</span> <span class="n">__UTILS_LOCKMODE_END__</span><span class="p">,</span>
                    <span class="n">__UTILS_FREEMODE_START__</span><span class="p">,</span> <span class="n">__UTILS_FREEMODE_END__</span><span class="p">,</span>
                    <span class="n">__UTILS_PROJECT_DYN__</span><span class="p">,</span> <span class="n">__UTILS_PROJECT_STRUCTURE__</span><span class="p">]</span>


<span class="n">NOT_INITIALIZED_ERROR</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Error, the ModeLocking has not been initialized, </span>
<span class="s2">please, consider running a function like: SetupFreeModes</span>
<span class="s2">before passing the mode locking function to the minimizer.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">get_custom_functions_from_namelist</span><span class="p">(</span><span class="n">namelist</span><span class="p">,</span> <span class="n">dyn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GET CFUNCTIONS FROM NAMELIST</span>
<span class="sd">    ============================</span>
<span class="sd">    </span>
<span class="sd">    This method reads a namelist and returns the three pointers</span>
<span class="sd">    to thee custom functions.</span>
<span class="sd">    </span>
<span class="sd">    NOTE: Up to know the mode locking is not abilitated</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        namelist : dict</span>
<span class="sd">            The dictionary containing the parsed namelist</span>
<span class="sd">        dyn : CC.Phonons.Phonons</span>
<span class="sd">            The dynamical matrix, used if you want to setup the</span>
<span class="sd">            mode locking</span>
<span class="sd">    </span>
<span class="sd">    Results</span>
<span class="sd">    -------</span>
<span class="sd">        cf_pre, cf_grad, cf_post:</span>
<span class="sd">            Three custom function to be executed, respectively,</span>
<span class="sd">            before, during and after the minimization step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">__UTILS_NAMESPACE__</span> <span class="ow">in</span> <span class="n">namelist</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error, the namespace </span><span class="si">%s</span><span class="s2"> is missing&quot;</span> <span class="o">%</span> <span class="n">__UTILS_NAMESPACE__</span><span class="p">)</span>
    
    <span class="n">c_info</span> <span class="o">=</span> <span class="n">namelist</span><span class="p">[</span><span class="n">__UTILS_NAMESPACE__</span><span class="p">]</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="n">c_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    
    <span class="n">use_io</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">use_modelocking</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="n">io_info</span> <span class="o">=</span> <span class="n">IOInfo</span><span class="p">()</span>
    
    <span class="c1"># Check for unknown keys</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">__ALLOWED_KEYS__</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Error with the key:&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span>  <span class="s2">&quot;Did you mean something like:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="n">difflib</span><span class="o">.</span><span class="n">get_close_matches</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">__ALLOWED_KEYS__</span><span class="p">))</span>
            <span class="nb">print</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error in &quot;</span><span class="o">+</span><span class="n">__UTILS_NAMESPACE__</span><span class="o">+</span><span class="s2">&quot; namespace: key &#39;&quot;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span><span class="s2">&quot;&#39; not recognized.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>
    
    
    
    <span class="k">if</span> <span class="n">__UTILS_SAVEFREQ_FILENAME__</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">use_io</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">io_info</span><span class="o">.</span><span class="n">SetupSaving</span><span class="p">(</span><span class="n">c_info</span><span class="p">[</span><span class="n">__UTILS_SAVEFREQ_FILENAME__</span><span class="p">])</span>
    
    <span class="k">if</span> <span class="n">__UTILS_SAVERHO_FILENAME__</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">use_io</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">io_info</span><span class="o">.</span><span class="n">SetupWeights</span><span class="p">(</span><span class="n">c_info</span><span class="p">[</span><span class="n">__UTILS_SAVERHO_FILENAME__</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">cfp</span><span class="p">(</span><span class="n">minim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">use_io</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;SAVING&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">io_info</span><span class="o">.</span><span class="n">CFP_SaveAll</span><span class="p">(</span><span class="n">minim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;NOT SAVING&quot;</span><span class="p">)</span>
        
    <span class="c1"># Setup the mode projection</span>
    <span class="n">locking</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">mu_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mu_end</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="k">if</span> <span class="n">__UTILS_LOCKMODE_START__</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">use_modelocking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">locking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mu_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c_info</span><span class="p">[</span><span class="n">__UTILS_LOCKMODE_START__</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">__UTILS_LOCKMODE_END__</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">use_modelocking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">locking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mu_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c_info</span><span class="p">[</span><span class="n">__UTILS_LOCKMODE_END__</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">__UTILS_FREEMODE_START__</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">use_modelocking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">locking</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, you cannot set both to free and lock modes.&quot;</span><span class="p">)</span>
        
        <span class="n">mu_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c_info</span><span class="p">[</span><span class="n">__UTILS_FREEMODE_START__</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">__UTILS_FREEMODE_END__</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">use_modelocking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">locking</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, you cannot set both to free and lock modes.&quot;</span><span class="p">)</span>
        
        <span class="n">mu_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">c_info</span><span class="p">[</span><span class="n">__UTILS_FREEMODE_END__</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        
    <span class="n">project_structure</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">project_dyn</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">__UTILS_PROJECT_DYN__</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">project_dyn</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">c_info</span><span class="p">[</span><span class="n">__UTILS_PROJECT_DYN__</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">__UTILS_PROJECT_STRUCTURE__</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">project_structure</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">c_info</span><span class="p">[</span><span class="n">__UTILS_PROJECT_STRUCTURE__</span><span class="p">])</span>
    
    
    <span class="c1"># Get the pols</span>
    <span class="n">nat</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span>
    <span class="n">nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">)</span>
    <span class="n">n_selected</span> <span class="o">=</span> <span class="n">mu_end</span> <span class="o">-</span> <span class="n">mu_start</span>
    <span class="k">if</span> <span class="n">n_selected</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, the start mode cannot be smaller than the final one.&quot;</span><span class="p">)</span>
        
    <span class="n">pols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">,</span> <span class="n">n_selected</span><span class="p">,</span> <span class="n">nq</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">use_modelocking</span><span class="p">:</span>
        
        <span class="k">if</span> <span class="n">mu_start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mu_start</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, the modes specified for modelocking must be between </span><span class="si">%d</span><span class="s2"> and </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">mu_end</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mu_end</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error, the modes specified for modelocking must be between </span><span class="si">%d</span><span class="s2"> and </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">nat</span><span class="p">))</span>

        <span class="c1"># for iq in range(nq):</span>
        <span class="c1">#     w, p_v = dyn.DyagDinQ(iq)</span>
        <span class="c1">#     pols[:, :, iq] = p_v[:, mu_start : mu_end]</span>
        
        <span class="c1"># # Setup the mode projection</span>
        <span class="c1"># ModProj = ModeProjection(pols, dyn.structure.get_masses_array())</span>
        <span class="n">ModProj</span> <span class="o">=</span> <span class="n">ModeProjection</span><span class="p">(</span><span class="n">dyn</span><span class="p">)</span>
        <span class="n">ModProj</span><span class="o">.</span><span class="n">SetupFreeModes</span><span class="p">(</span><span class="n">mu_start</span><span class="p">,</span> <span class="n">mu_end</span><span class="p">)</span>
    
        <span class="k">def</span> <span class="nf">modlock</span><span class="p">(</span><span class="n">dyn_grad</span><span class="p">,</span> <span class="n">struct_grad</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">project_dyn</span> <span class="ow">and</span> <span class="n">project_structure</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">locking</span><span class="p">:</span>
                     <span class="c1"># Project out the modes</span>
                     <span class="n">dyn1</span> <span class="o">=</span> <span class="n">dyn_grad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                     <span class="n">struc1</span> <span class="o">=</span> <span class="n">struct_grad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                     
                     <span class="n">ModProj</span><span class="o">.</span><span class="n">CFG_ProjectOnModes</span><span class="p">(</span><span class="n">dyn1</span><span class="p">,</span> <span class="n">struc1</span><span class="p">)</span>
                     <span class="n">dyn_grad</span> <span class="o">-=</span> <span class="n">dyn1</span>
                     <span class="n">struct_grad</span> <span class="o">-=</span> <span class="n">struc1</span>
                <span class="k">else</span><span class="p">:</span>
                     <span class="n">ModProj</span><span class="o">.</span><span class="n">CFG_ProjectOnModes</span><span class="p">(</span><span class="n">dyn_grad</span><span class="p">,</span> <span class="n">struct_grad</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">project_dyn</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">locking</span><span class="p">:</span>
                     <span class="c1"># Project out the modes</span>
                     <span class="n">dyn1</span> <span class="o">=</span> <span class="n">dyn_grad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                     
                     <span class="n">ModProj</span><span class="o">.</span><span class="n">CFG_ProjectDyn</span><span class="p">(</span><span class="n">dyn1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                     <span class="n">dyn_grad</span> <span class="o">-=</span> <span class="n">dyn1</span>
                <span class="k">else</span><span class="p">:</span>
                     <span class="n">ModProj</span><span class="o">.</span><span class="n">CFG_ProjectDyn</span><span class="p">(</span><span class="n">dyn_grad</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">project_structure</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">locking</span><span class="p">:</span>
                     <span class="c1"># Project out the modes</span>
                     <span class="n">struc1</span> <span class="o">=</span> <span class="n">struct_grad</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                     
                     <span class="n">ModProj</span><span class="o">.</span><span class="n">CFG_ProjectStructure</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">struc1</span><span class="p">)</span>
                     <span class="n">struct_grad</span> <span class="o">-=</span> <span class="n">struc1</span>
                <span class="k">else</span><span class="p">:</span>
                     <span class="n">ModProj</span><span class="o">.</span><span class="n">CFG_ProjectStructure</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">struct_grad</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Internal error, asked for mode locking but neither the dyn or the structure is locked.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">modlock</span><span class="p">,</span> <span class="n">cfp</span>
    
    <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cfp</span>
        


<div class="viewcode-block" id="ModeProjection"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.ModeProjection">[docs]</a><span class="k">class</span> <span class="nc">ModeProjection</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dyn</span><span class="p">):</span><span class="c1">#pols, masses_array):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class is used to project the gradient in or out of</span>
<span class="sd">        a space generated by the mode in the pols array.</span>
<span class="sd">        </span>
<span class="sd">        The projection on the subspace is done in the following way.</span>
<span class="sd">        The force constant matrix is transformed in the dynamical matrix:</span>
<span class="sd">            </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            D = M^{-\\frac 1 2} \\Phi M^{-\\frac 1 2}</span>
<span class="sd">            </span>
<span class="sd">            D_{proj} = \\sum_{\\mu} \\left|e_\\mu\\right&gt; \\left&lt;e_\\mu\\right| D \\left|e_\\mu\\right&gt; \\left&lt;e_\\mu\\right|</span>
<span class="sd">            </span>
<span class="sd">            \\Phi_{proj} = M^{\\frac 1 2} D_{proj} M^{\\frac 1 2}</span>
<span class="sd">            </span>
<span class="sd">        This means that the projection is done with the two operators</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>
<span class="sd">            </span>
<span class="sd">            \\Phi_{proj} = P^\\dagger \\Phi P</span>
<span class="sd">            </span>
<span class="sd">            P = \\sum_{\\mu} M^{-\\frac 12}\\left|e_\\mu\\right&gt; \\left&lt;e_\\mu\\right| M^{\\frac 12}</span>
<span class="sd">            </span>
<span class="sd">        The same matrix is used to project the vectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            dyn : Phonons()</span>
<span class="sd">                The dynamical matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Prepare the modes to be locked</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nat</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">nmodes</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">nq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">)</span>

        <span class="c1"># Get the polarization vectors for each q point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">):</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">DyagDinQ</span><span class="p">(</span><span class="n">iq</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pols</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> 

            <span class="c1"># Check normalization of p</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodes</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">,</span> <span class="s2">&quot;Error, for some reason vectors are not normalized&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">masses</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">get_masses_array</span><span class="p">()</span>
        
        
        <span class="c1"># Prepare the projector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projectorH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mu_start</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">#index_mode_start </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_end</span> <span class="o">=</span> <span class="mi">0</span><span class="c1">#index_mode_end</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">testing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constrain</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_q_points</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="ModeProjection.SetupFreeModes"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.ModeProjection.SetupFreeModes">[docs]</a>    <span class="k">def</span> <span class="nf">SetupFreeModes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_mode_start</span><span class="p">,</span> <span class="n">index_mode_end</span><span class="p">,</span> <span class="n">select_q_points</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">constrain</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SETUP FREE (or constrained) MODES</span>
<span class="sd">        =================================</span>

<span class="sd">        Constrain the minimization only in the modes between index_modes_start and</span>
<span class="sd">        index_mdoe_end in all the q points. Also the opposite is possible, </span>
<span class="sd">        by setting the constrain flag to True.</span>

<span class="sd">        For each q points only modes between these indices will be minimized.</span>
<span class="sd">        The select_q_points options allows to select only some q points to be constrained.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            index_mode_start : int</span>
<span class="sd">                The index of the first mode</span>
<span class="sd">            index_mode_end : int</span>
<span class="sd">                The index of the last mode</span>
<span class="sd">            select_q_points : list of int</span>
<span class="sd">                The index of the q points affected. </span>
<span class="sd">                If None (default) all q points are affected.</span>
<span class="sd">            constrain : bool</span>
<span class="sd">                If True, the specified range of modes is constrained while all the other are free.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constrain</span> <span class="o">=</span> <span class="n">constrain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_q_points</span> <span class="o">=</span> <span class="n">select_q_points</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mu_start</span> <span class="o">=</span> <span class="n">index_mode_start</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">mu_end</span> <span class="o">=</span> <span class="n">index_mode_end</span>

        <span class="c1"># Generate the array for the masses aligned as the polarization vector</span>
        <span class="n">_m_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="n">_msq_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">_m_</span><span class="p">)</span>
        
        <span class="c1"># Setup the projector on the dynamical matrix</span>
        <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">select_q_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Skip the q points not in select_q_points</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">iq</span> <span class="ow">in</span> <span class="n">select_q_points</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index_mode_start</span><span class="p">,</span> <span class="n">index_mode_end</span><span class="p">):</span>
                <span class="n">pvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pols</span><span class="p">[:,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">iq</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
                <span class="c1">#pvec /= pvec.dot(pvec) # Normalization</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">projector</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">pvec</span> <span class="o">/</span> <span class="n">_msq_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">pvec</span><span class="p">)</span> <span class="o">*</span> <span class="n">_msq_</span> <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">projectorH</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">pvec</span><span class="o">*</span><span class="n">_msq_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">pvec</span><span class="p">)</span> <span class="o">/</span> <span class="n">_msq_</span><span class="p">)</span>
                
        <span class="c1"># Prepare the projector on the structure</span>
        <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index_mode_start</span><span class="p">,</span> <span class="n">index_mode_end</span><span class="p">):</span>
            <span class="n">pvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pols</span><span class="p">[:,</span> <span class="n">mu</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pvec</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">pvec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pvec</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj_vec</span><span class="p">[:,:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">pvec</span> <span class="o">/</span> <span class="n">_msq_</span><span class="p">,</span> <span class="n">pvec</span> <span class="o">*</span> <span class="n">_msq_</span><span class="p">)</span>
        
        <span class="c1"># If the constrain is chosen, reverse the projectors</span>
        <span class="k">if</span> <span class="n">constrain</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">proj_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodes</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_vec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">projector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodes</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">projector</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">projectorH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmodes</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectorH</span>
                

        <span class="c1"># Impose the sum rule </span>
        <span class="c1"># Note that in principle it should be satisfied, however the python diagonalization</span>
        <span class="c1"># sucks, therefore the polarization vector are not exactly orthonormal.</span>
        <span class="n">CC</span><span class="o">.</span><span class="n">symmetries</span><span class="o">.</span><span class="n">CustomASR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projector</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span></div>

<div class="viewcode-block" id="ModeProjection.CFG_ProjectOnModes"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.ModeProjection.CFG_ProjectOnModes">[docs]</a>    <span class="k">def</span> <span class="nf">CFG_ProjectOnModes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dyn_grad</span><span class="p">,</span> <span class="n">struct_grad</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PROJECT THE GRADIENT IN THE SELECTED MODES</span>
<span class="sd">        ==========================================</span>


<span class="sd">        Function to be passed to the minimizer as &#39;custom_function_gradient&#39;. </span>
<span class="sd">        It project the gradients in the polarization vector subspace.</span>
<span class="sd">        As any custom_function_gradient, it takes as input the two gradients.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">,</span> <span class="n">NOT_INITIALIZED_ERROR</span>

        <span class="c1"># Project the structure in the polarization vectors</span>
        <span class="n">struct_grad_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_vec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">struct_grad</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">struct_grad</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">struct_grad_new</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="n">_m_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">masses</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Do the same for the matrix</span>
        <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">):</span>
            <span class="c1"># Skip the q points not in the list</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_q_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">iq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_q_points</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="c1"># remove the masses from the gradient</span>
            <span class="n">grad_nomass</span> <span class="o">=</span> <span class="n">dyn_grad</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">_m_</span><span class="p">,</span> <span class="n">_m_</span><span class="p">))</span>

            <span class="c1"># Transfer in polarization space</span>
            <span class="n">grad_polbasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pols</span><span class="p">[:,:,</span> <span class="n">iq</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">grad_nomass</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pols</span><span class="p">[:,:,</span><span class="n">iq</span><span class="p">]))</span>

            <span class="c1"># Fix the modes</span>
            <span class="n">projected_grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grad_polbasis</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
            <span class="c1">#print(&quot;MU START:&quot;, self.mu_start, &quot;MU END:&quot;, self.mu_end)</span>
            <span class="n">projected_grad</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_polbasis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_end</span><span class="p">]</span> 

            <span class="c1"># Reverse the projection if needed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constrain</span><span class="p">:</span>
                <span class="n">projected_grad</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">grad_polbasis</span><span class="p">[:,:]</span> <span class="o">-</span> <span class="n">projected_grad</span><span class="p">[:,:]</span>


            <span class="c1"># Go back in cartesian coordinates</span>
            <span class="n">projected_grad_cart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pols</span><span class="p">[:,:,</span> <span class="n">iq</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projected_grad</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pols</span><span class="p">[:,:,</span><span class="n">iq</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

            <span class="c1"># Put the masses again and overwrite the gradient</span>
            <span class="n">new_dyngrad</span> <span class="o">=</span> <span class="n">projected_grad_cart</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">_m_</span><span class="p">,</span> <span class="n">_m_</span><span class="p">))</span>

            <span class="c1"># Check if the grad increased </span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">testing</span><span class="p">:</span>
                <span class="n">norm_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dyn_grad</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">norm_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_dyngrad</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> 

                <span class="k">if</span> <span class="n">norm_new</span> <span class="o">&gt;</span> <span class="n">norm_old</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error on q = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iq</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Old norm: </span><span class="si">{}</span><span class="s2"> | New norm: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">norm_old</span><span class="p">,</span> <span class="n">norm_new</span><span class="p">))</span> 
                
                <span class="k">assert</span> <span class="n">norm_new</span> <span class="o">&lt;</span> <span class="n">norm_old</span>

            <span class="n">dyn_grad</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">new_dyngrad</span></div>
                    
            <span class="c1">#dyn_grad[iq, :, :] = self.projectorH[iq, :, :].dot(dyn_grad[iq, :, :].dot(self.projector[iq, :, :]))</span>
            <span class="c1"># Lets check if the matrix satisfy the sum rule</span>
            <span class="c1">#print &quot;DIAG:&quot;, np.linalg.eigvalsh(dyn_grad[iq, :, :])</span>
            
<div class="viewcode-block" id="ModeProjection.CFG_ProjectStructure"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.ModeProjection.CFG_ProjectStructure">[docs]</a>    <span class="k">def</span> <span class="nf">CFG_ProjectStructure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dyn_grad</span><span class="p">,</span> <span class="n">struct_grad</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PROJECT ONLY THE STRUCTURE GRADIENT IN THE SELECTED MODES</span>
<span class="sd">        =========================================================</span>
<span class="sd">        </span>
<span class="sd">        This subroutine constraints only the structure gradient, leaving the</span>
<span class="sd">        dynamical matrix to minimize on all the possible degrees of freedom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">,</span> <span class="n">NOT_INITIALIZED_ERROR</span>

        <span class="c1"># Project the structure in the polarization vectors</span>
        <span class="n">struct_grad_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_vec</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">struct_grad</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">struct_grad</span> <span class="o">=</span> <span class="n">struct_grad_new</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nat</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span></div>
            
<div class="viewcode-block" id="ModeProjection.CFG_ProjectDyn"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.ModeProjection.CFG_ProjectDyn">[docs]</a>    <span class="k">def</span> <span class="nf">CFG_ProjectDyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dyn_grad</span><span class="p">,</span> <span class="n">struct_grad</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PROJECT ONLY THE FC GRADIENT IN THE SELECTED MODES</span>
<span class="sd">        ==================================================</span>
<span class="sd">        </span>
<span class="sd">        This subroutine constrains only the dynamical matrix, leaving the structure</span>
<span class="sd">        to minimize on all the possible degrees of freedom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized</span><span class="p">,</span> <span class="n">NOT_INITIALIZED_ERROR</span>
        
        <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nq</span><span class="p">):</span>
            <span class="n">dyn_grad</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projectorH</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dyn_grad</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projector</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]))</span></div></div>







<div class="viewcode-block" id="IOInfo"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.IOInfo">[docs]</a><span class="k">class</span> <span class="nc">IOInfo</span><span class="p">:</span>
    
    <span class="n">save_weights</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">weights_file</span> <span class="o">=</span> <span class="s2">&quot;weights.dat&quot;</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">save_dynmats</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ka</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">save_dyn_prefix</span> <span class="o">=</span> <span class="s2">&quot;minim_dyn&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class is meant to deal with standard verbose I/O operation,</span>
<span class="sd">        like printing the frequencies as a function of the time step of a dynamical matrix (and so on)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">total_freqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__save_fname</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__save_atoms_fname</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_atomic_positions</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__save_each_step</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_struct</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="IOInfo.Reset"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.IOInfo.Reset">[docs]</a>    <span class="k">def</span> <span class="nf">Reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the data to empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="IOInfo.SetupWeights"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.IOInfo.SetupWeights">[docs]</a>    <span class="k">def</span> <span class="nf">SetupWeights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">save_each_step</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup the weights saving</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            fname : string</span>
<span class="sd">                Path to the file to which save the frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">weights_file</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_weights</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__save_each_step</span> <span class="o">=</span> <span class="n">save_each_step</span></div>

<div class="viewcode-block" id="IOInfo.SetupAtomicPositions"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.IOInfo.SetupAtomicPositions">[docs]</a>    <span class="k">def</span> <span class="nf">SetupAtomicPositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">save_each_step</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup the saving of the data on atomic position along with the minimization</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__save_atoms_fname</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_atomic_positions</span> <span class="o">=</span> <span class="kc">True</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">__save_each_step</span> <span class="o">=</span> <span class="n">save_each_step</span></div>


<div class="viewcode-block" id="IOInfo.SetupSaving"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.IOInfo.SetupSaving">[docs]</a>    <span class="k">def</span> <span class="nf">SetupSaving</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">save_each_step</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup the system to save the data each time the function is called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            fname : string </span>
<span class="sd">                path to the file to save the frequencies vs time</span>
<span class="sd">            save_each_step : bool</span>
<span class="sd">                If true the file is saved (and updated) each time step.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__save_fname</span> <span class="o">=</span> <span class="n">fname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__save_each_step</span> <span class="o">=</span> <span class="n">save_each_step</span></div>

<div class="viewcode-block" id="IOInfo.Save"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.IOInfo.Save">[docs]</a>    <span class="k">def</span> <span class="nf">Save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the data on a file</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            fname : string, optional</span>
<span class="sd">                If given, the file will be saved in the specified location.</span>
<span class="sd">                Otherwise the default one is used (must be initialized by SetupSaving)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sscha</span><span class="o">.</span><span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__save_fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Error, a filename must be specified to save the frequencies.&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__save_fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_freqs</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;Time vs Frequencies&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_freqs</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;Time vs Frequencies&quot;</span><span class="p">)</span>
            
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_weights</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights_file</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">),</span> <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;Each row is a step containing all the weights of the configurations&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_atomic_positions</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_struct</span><span class="o">.</span><span class="n">save_scf</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">get_text</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__save_atoms_fname</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>
            
            
        
<div class="viewcode-block" id="IOInfo.CFP_SaveAll"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.IOInfo.CFP_SaveAll">[docs]</a>    <span class="k">def</span> <span class="nf">CFP_SaveAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method saves everithing stored in this class.</span>
<span class="sd">        </span>
<span class="sd">        It can be passed as custom_function_post to the run method of the SchaMinimizer.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="n">sscha</span><span class="o">.</span><span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">():</span>
            <span class="k">return</span>
        
        <span class="c1"># Get the weights if required</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_weights</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minim</span><span class="o">.</span><span class="n">ensemble</span><span class="o">.</span><span class="n">rho</span><span class="p">[:])</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_dynmats</span><span class="p">:</span>
            <span class="n">minim</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">save_qe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">save_dyn_prefix</span> <span class="o">+</span> <span class="s2">&quot;_ka</span><span class="si">%05d</span><span class="s2">_&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ka</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_atomic_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_struct</span> <span class="o">=</span> <span class="n">minim</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
        <span class="c1"># This perform also the saving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CFP_SaveFrequencies</span><span class="p">(</span><span class="n">minim</span><span class="p">)</span>
        
        <span class="c1"># Update the step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ka</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="IOInfo.CFP_SaveFrequencies"><a class="viewcode-back" href="../../apireference.html#sscha.Utilities.IOInfo.CFP_SaveFrequencies">[docs]</a>    <span class="k">def</span> <span class="nf">CFP_SaveFrequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This custom method stores the total frequencies updating an exeternal file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Generate the supercell in real space</span>
        <span class="n">dyn_sc</span> <span class="o">=</span> <span class="n">minim</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">GenerateSupercellDyn</span><span class="p">(</span> <span class="n">minim</span><span class="o">.</span><span class="n">ensemble</span><span class="o">.</span><span class="n">supercell</span> <span class="p">)</span>

        <span class="c1"># Dyagonalize</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">pols</span> <span class="o">=</span> <span class="n">dyn_sc</span><span class="o">.</span><span class="n">DyagDinQ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_freqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__save_each_step</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Save</span><span class="p">()</span></div></div>



<span class="k">def</span> <span class="nf">get_fix_rotations_CFG</span><span class="p">(</span><span class="n">dyn</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FIX ROTATIONS</span>
<span class="sd">    =============</span>

<span class="sd">    This function returns a pointer to a function that allows to fix the rotational degrees of freedom.</span>

<span class="sd">    It can be used when minimizing nanostructures or particles.</span>
<span class="sd">    The dynamical matrix must be a gamma point matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Error, only Gamma calculations can fix the rotations.&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dyn</span><span class="o">.</span><span class="n">q_tot</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="s2">&quot;Error, the dynamical matrix must be at Gamma&quot;</span>

    <span class="n">nat</span> <span class="o">=</span> <span class="n">dyn</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">N_atoms</span> 
    <span class="c1"># TODO: To be ended</span>
    
    

<span class="k">def</span> <span class="nf">save_binary</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SAVE EVERYTHING</span>
<span class="sd">    ===============</span>

<span class="sd">    This method saves the whole status of a class (it may be the relax or even the minimizer)</span>
<span class="sd">    So that it can be used for analyzing the results. </span>
<span class="sd">    It will recursivly contain all the data stored by the class, included the ensemble and the dynamical matrices.</span>

<span class="sd">    The file will be in binary.</span>

<span class="sd">    NOTE: There is no warranty that the fill will be readable when loaded with a different python version.</span>

<span class="sd">    For this reason, if you want to store the ensemble, the save_bin from ensemble is strongly suggested.</span>

<span class="sd">    This methods is just a wrapper for the python pickle utility.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        object : anything</span>
<span class="sd">            The python object you want to save, it may even be a class. </span>
<span class="sd">        filename : string (path to file)</span>
<span class="sd">            The filename on which you want to save the binary data.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="n">sscha</span><span class="o">.</span><span class="n">Parallel</span><span class="o">.</span><span class="n">am_i_the_master</span><span class="p">():</span>
        <span class="k">return</span>
    
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">load_binary</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LOAD EVERYTHING</span>
<span class="sd">    ===============</span>

<span class="sd">    This method loads the whole status of a class (it may be the relax or even the minimizer)</span>
<span class="sd">    So that it can be used for analyzing the results. </span>
<span class="sd">    It will recursivly contain all the data stored by the class, included the ensemble and the dynamical matrices.</span>

<span class="sd">    It can read data generated with save_binary</span>

<span class="sd">    NOTE: There is no warranty that the fill will be readable when loaded with a different python version.</span>

<span class="sd">    This methods is just a wrapper for the python pickle utility.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        filename : string (path to file)</span>
<span class="sd">            The filename you want to read</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index1.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Lorenzo Monacelli.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>